<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Czm blog</title>
    <link>https://puppym.github.io/blog/</link>
    <description>Recent content on Czm blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 04 Jan 2020 16:21:44 +0800</lastBuildDate>
    
        <atom:link href="https://puppym.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go Sheduler</title>
      <link>https://puppym.github.io/blog/go-scheduler/</link>
      <pubDate>Sat, 04 Jan 2020 16:21:44 +0800</pubDate>
      
      <guid>https://puppym.github.io/blog/go-scheduler/</guid>
      
        <description>

&lt;h2 id=&#34;go-调度器&#34;&gt;go 调度器&lt;/h2&gt;

&lt;h3 id=&#34;介绍&#34;&gt;介绍&lt;/h3&gt;

&lt;p&gt;Go 1.1的最重要的一个特性是引入了新的调度器，由Dmitry Vyukov贡献， 新的调度器极大的提高了程序的并行性能。&lt;/p&gt;

&lt;h3 id=&#34;go-runtime需要一个怎样的调度器&#34;&gt;go runtime需要一个怎样的调度器？&lt;/h3&gt;

&lt;p&gt;但是在查看新的调度器之前，我们需要了解为什么需要它。当操作系统可以为您调度线程时为什么需要创建用户进空间的线程（goroutine）?&lt;/p&gt;

&lt;p&gt;POSIX线程API是现有Unix进程模型的逻辑扩展，因此，线程可以获得与进程相同的许多控件。线程有自己的信号掩码，可以分配CPU亲缘关系，可以放在cgroups中，可以查询它们使用哪些资源。所有这些控件都为Go程序使用goroutines所不需要的功能增加了开销，当程序中有100,000个线程时，这些开销就会迅速增加。&lt;/p&gt;

&lt;p&gt;另一个问题是，基于Go模型操作系统无法做出明智的调度决策。例如，Go垃圾收集器要求在运行收集动作时停止所有线程，并且内存必须处于一致的状态。这涉及到等待正在运行的线程到达一个内存是一致的点。&lt;/p&gt;

&lt;p&gt;当您在一个随机时间点调度许多线程时，很可能需要等待许多线程达到一致的状态。Go调度器只能在内存是一致的地方进行调度。这意味着，当我们停止垃圾收集动作时，我们不得不取等待正在CPU核上积极运行的线程。&lt;/p&gt;

&lt;p&gt;通常有3个线程模型。一个是N:1，其中几个用户空间线程在一个OS线程上运行。这样做的优点是可以非常快速地切换上下文，但是不能利用多核系统。另一个是1:1，其中一个执行线程与一个操作系统线程匹配，它利用了机器上的所有核心，但是上下文切换很慢，因为上下文的切换也就是物理线程的切换，需要操作系统的介入。&lt;/p&gt;

&lt;p&gt;Go试图通过使用M:N调度器来同时利用这两个方面。它将任意数量的goroutine调度到任意数量的OS线程上。您可以快速切换上下文，并利用系统中的所有核心。这种方法的主要缺点是它增加了调度器的复杂性。&lt;/p&gt;

&lt;h3 id=&#34;go-scheduler-组成&#34;&gt;go-scheduler 组成&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;为了完成调度任务，Go调度器使用3个主要实体&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;G: goroutine包含堆栈，指令指针和其他协程调度的重要信息，比如任何可能被阻塞的channel。在runtime的代码中它被称为G。&lt;/p&gt;

&lt;p&gt;P: 逻辑处理器Processor，其代表调度的上下文，您可以将它看作是在单个线程上运行Go代码的调度程序的本地化版本。P是重要的对于让我们从老版本的GM模式的N:1转换到GPM模式的M:N（协程：物理线程）。在runtime中他被称为P，p的值可以被 &lt;code&gt;GOMAXPROCS()&lt;/code&gt;函数所设置。&lt;/p&gt;

&lt;p&gt;M: M是直接被OS调度管理的物理线程，它非常像标准的POSIX线程。在runtime中，它被称为M for Machine。&lt;/p&gt;

&lt;p&gt;下面的图可以表示其3者者之间的关系：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://morsmachine.dk/in-motion.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在上面我们看到2个线程(M)，每个M都有一个context(P)和一个正在运行的goroutine(G)。为了运行G，一个M必须拥有一个P。&lt;/p&gt;

&lt;p&gt;P的数量可以用环境变量GOMAXPROCS和runtime中的&lt;code&gt;GOMAXPROCS()&lt;/code&gt;函数来设置，正常来说该值不会被改变。并且在go语言后面的版本中该值固定为CPU的逻辑核数。&lt;/p&gt;

&lt;p&gt;灰色的协程没有被运行，但是它准备被调度，他们被排列在runqueues队列中， 该队列采用FIFO的进出方式。当协程执行go语句时，它被放到runqueues的结尾，P会运行一个协程直到到达调度时间点，然后P会从runqueue队列中取出G，然后设置栈和指令指针开始运行协程。&lt;/p&gt;

&lt;p&gt;为了降低由多个P的情况下对于runqueue的互斥争用情况，每一个P都有自己的local runqueue。在之前的版本中go的调度器仅仅只有一个全局的runqueue，并且用一个互斥锁来保护它。线程经常会为了等待runqueue的互斥锁而被阻塞。当你想充分利用一个32核心机器上的计算资源时，这会变得更加糟糕。&lt;/p&gt;

&lt;p&gt;只要所有上下文都有goroutines要运行，调度器就会在这种稳定状态下继续调度。然而，有两个场景可以改变这种情况。&lt;/p&gt;

&lt;h4 id=&#34;syscall&#34;&gt;syscall&lt;/h4&gt;

&lt;p&gt;你可能会想，为什么要有P呢?我们不能把runqueue放到线程M上，然后去掉上下文P吗?我们有上下文P的原因是，如果正在运行的线程由于某种原因需要阻塞，我们可以将它们传递给其他线程。&lt;/p&gt;

&lt;p&gt;一个线程可能阻塞的例子是当我们调用一个系统调用时，线程可能会被阻塞在syscall上，因此在线程M阻塞时，应该传递上下文P，使得它能够继续调度其余G。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://morsmachine.dk/syscall.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在上面的图中，我们看到一个线程M0放弃了上下文P，以便另外一个线程M1能够运行该上下文。go调度器确保有足够的线程来运行上下文P。上面例子中的M1可能只是为了处理这个syscall而创建的，也可能来自线程的缓存(线程复用)。syscall线程M0将保持协程G0一直处理系统调用，G0尽管被阻塞了，但是从技术的角度来说它任然在执行。&lt;/p&gt;

&lt;p&gt;当syscall返回时，为了运行返回的goroutine，线程必须尝试获取一个上下文P。正常的操作模式是从其他线程之一窃取上下文P。如果它不能窃取一个，它将把goroutine放到一个全局运行队列中，把自己放到线程缓存中，然后休眠。&lt;/p&gt;

&lt;p&gt;上下文P的本地运行队列取出G取完后会到全局运行队列中去取。上下文P还会定期检查全局运行队列中的goroutines。否则，全局运行队列上的goroutines可能会因为饥饿而停止运行。&lt;/p&gt;

&lt;p&gt;这种对系统调用的处理就是为什么Go程序能够运行多个线程，即使GOMAXPROCS为1。runtime来用goroutines通过线程进行系统调用，线程阻塞时，就将线程放在一边。&lt;/p&gt;

&lt;h4 id=&#34;stealing-work&#34;&gt;Stealing work&lt;/h4&gt;

&lt;p&gt;go调度系统稳定状态改变的另一种方式是当上下文P耗尽了要调度的goroutines时，如果上下文P的运行队列上的G数量不平衡，这将导致有的上下文P耗尽了它的运行队列，但是系统中仍然有工作要做。为了继续高效的运行代码，上下文P首先将从全局队列中获取G，如果当中没有G，它会从其余上下文P中取一半的G，这确保了每一个上下文P都是处于工作状态以及所有线程都在以最大容量G工作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://morsmachine.dk/steal.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;总结上面调度器为了达到平衡状态而做的两个动作。syscall可以总结当G导致M阻塞时，P向下抛弃M。steal work可以总结为P执行完所有G后，从全局运行队列和其余P中调度一半G。&lt;/p&gt;

&lt;h3 id=&#34;goroutine-调度&#34;&gt;goroutine 调度&lt;/h3&gt;

&lt;p&gt;Go运行时会在下面的goroutine被阻塞的情况下运行另外一个goroutine。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;blocking syscall(for example opening a file)&lt;/li&gt;
&lt;li&gt;network input&lt;/li&gt;
&lt;li&gt;channel operations&lt;/li&gt;
&lt;li&gt;primitives in the sync package&lt;/li&gt;
&lt;li&gt;The Go statement, although there is no guarantee that new goroutine will be scheduled immediately.&lt;/li&gt;
&lt;li&gt;After being stopped for a garbage collection cycle.&lt;a href=&#34;https://codeburst.io/why-goroutines-are-not-lightweight-threads-7c460c1f155f&#34;&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;sysmon&#34;&gt;sysmon&lt;/h3&gt;

&lt;p&gt;sysmon是一个由runtime启动的M，也叫监控线程，它无需P也可以运行，它每20us~10ms唤醒一次，主要执行:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;释放闲置超过5分钟的span物理内存； scavenge heap&lt;/li&gt;
&lt;li&gt;如果超过2分钟没有垃圾回收，强制执行；forcegc&lt;/li&gt;
&lt;li&gt;将长时间未处理的netpoll结果添加到任务队列；netpool&lt;/li&gt;
&lt;li&gt;向长时间运行的G任务发出抢占调度；retake&lt;a href=&#34;http://xiaorui.cc/2018/06/04/golang%e5%af%86%e9%9b%86%e5%9c%ba%e6%99%af%e4%b8%8b%e5%8d%8f%e7%a8%8b%e8%b0%83%e5%ba%a6%e9%a5%a5%e9%a5%bf%e9%97%ae%e9%a2%98/&#34;&gt;golang-Cpu密集型任务调度抢占&lt;/a&gt;。这里发生抢占其实是一种伪抢占，本质上是sysmon中的retake触发morestack，然后调用newstack，然后gopreempt_m会重置g的状态，并且扔到本地runq中重新进行调度。&lt;/li&gt;
&lt;li&gt;收回因syscall长时间阻塞的P；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;go调度器还有很多细节，比如cgo线程LockOSThread()函数以及与网络轮询器的集成。这些都能够在go的runtime库中能够找到。&lt;/p&gt;

&lt;h4 id=&#34;参考&#34;&gt;参考&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://morsmachine.dk/go-scheduler&#34;&gt;go-scheduler&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://wudaijun.com/2018/01/go-scheduler/&#34;&gt;go-scheduler1&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Geth_query</title>
      <link>https://puppym.github.io/blog/geth-query/</link>
      <pubDate>Thu, 02 Jan 2020 09:41:04 +0800</pubDate>
      
      <guid>https://puppym.github.io/blog/geth-query/</guid>
      
        <description>

&lt;h2 id=&#34;以太坊智能合约数据高速抽取和重放&#34;&gt;以太坊智能合约数据高速抽取和重放&lt;/h2&gt;

&lt;p&gt;为了解决从海量的区块数据中快速提取智能合约运行特征，本文提出智能合约数据快速抽取和重放技术。解决以太坊从海量区块数据中抽取合约运行状态难和利用合约运行状态实时监控合约状态难的问题。主要的分为以下几个部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;智能合约状态的自动抽取。智能合约再链上执行过程中，每一个状态都有可能导致其世界状态的变化。在同步区块数据时，通过适当保存合约运行的中间状态，能够实现智能合约的定点重放。&lt;/li&gt;
&lt;li&gt;智能合约执行过程的快速重放。通过优化本地的EVM，更改EVM的内部结构，通过EVM快速重发智能合约以及抽取合约运行特征。&lt;/li&gt;
&lt;li&gt;面向区块链的同步缓存技术。通过存储智能合约重发运行特征以及区块数据，并且提供高效的外部查询接口。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;智能合约状态的自动抽取&#34;&gt;智能合约状态的自动抽取&lt;/h3&gt;

&lt;p&gt;智能合于运行在区块链虚拟环境中，不存在直观的标准化接口能够访问合约中的各类状态。事实上，单一合约状态的变化会影响整个区块链状态的变化，而且这种变化会随着区块高度和交易数量而不断增加，甚至随着合约代码的逐步调用执行而时刻发生变化。例如，合约的单步执行即可导致自身状态变化，或导致多个账户余额更改，或导致其他合约的状态发生变化。因此为了快速定位需要的信息，高效筛选合约状态至关重要，本部分通过对智能合约特性深入分析，筛选出不同维度的链上信息进行处理和快照，如区块，交易，收据，事件日志，合约基本全貌信息，特定类型合约信息，合约内部调用记录，合约逐步调用轨迹等。这些信息从粗至细记录了合约在链上的所有状态，可以满足不同场景下的分析需求。&lt;/p&gt;

&lt;p&gt;智能合约数据抽取过程具体如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过以太坊Geth客户端启动全节点，全节点会启动一系列服务，P2P服务从其他以太坊全节点通过P2P连接同步区块数据到内存。&lt;/li&gt;
&lt;li&gt;Geth客户端按区块顺序遍历执行每个区块和区块中的每一笔交易，在执行过程中快照保存每个区块的世界状态和智能合约数据存储的中间状态，便于通过快照状态重放智能合约。&lt;/li&gt;
&lt;li&gt;每笔交易的执行会对应一个新的EVM虚拟机，EVM虚拟机通过合约账户的code域按顺序读取智能合约的opcode指令执行，快照保存指定opcode执行状态，通过执行opcode识别内部交易，保存内部交易数据。&lt;/li&gt;
&lt;li&gt;交易执行结束，保存交易数据，以及交易返回的票据数据。&lt;/li&gt;
&lt;li&gt;区块执行结束，保存区块数据，向底层levelDB数据库commit数据更新。&lt;/li&gt;
&lt;li&gt;重复上述操作，直至全节点跟上主网的同步状态。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;C:Usersczm18Desktop开题报告简化以太坊数据抽取图中文 (1).png&#34; alt=&#34;简化以太坊数据抽取图中文 (1)&#34; /&gt;&lt;/p&gt;

&lt;p&gt;另一方面，合约状态和区块交易中还包含大量冗余信息，对长期数据存储同步以及后续分析带来极大的压力，后面会对数据使用颗粒化快照策略，对这部分信息进行过滤。&lt;/p&gt;

&lt;h3 id=&#34;智能合约执行过程重放优化&#34;&gt;智能合约执行过程重放优化&lt;/h3&gt;

&lt;p&gt;针对智能合约依赖特定运行环境以及合约状态时间依赖问题，本文研究合约任意状态恢复，合约虚拟机跟踪调试，合约运行资源消耗复原。&lt;/p&gt;

&lt;p&gt;智能合约和区块链本质上是一个状态机系统，智能合约的逐步执行造成状态的改变和转移。本文通过记录区块链每个区块下的状态，以及在交易维度下的每次状态差异，实现最小代价维护整个区块链系统的关键状态转移信息。另外，通过索引每个交易trace和交易内的虚拟机执行trace,保留最精细的执行过程信息。这种设计下，可以实现以下多维度的执行过程重发：任意区块内的所有交易执行重放；任意交易的执行过程重放；任意合约执行过程中虚拟机状态重放。前面提到记录的每次状态差异即可用于快速对比合约执行效果，也用于高效复原任意节点的完整合约状态。最终通过此套方案快速恢复智能合约在历史上任意时刻的状态。并且由于对EVM进行了优化，通过过滤关键的trace信息和去除交易执行完后向底层数据库LevelDB的写操作，能够极大加快EVM重放交易的速度。智能合约执行过程重发执行步骤主要如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;启动智能合约重放工具Geth-query,Geth-query服务读取全节点数据库LevelDB中的区块数据和区块世界状态快照，恢复重放区块或交易的世界状态。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Geth-query服务按区块顺序遍历执行每个区块和区块中的每一笔交易，通过对每一笔交易都新建一个EVM虚拟机开始执行交易。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;EVM虚拟机通过合约账户的code域按顺序读取智能合约的opcode指令执行，快照保存指定opcode执行状态，通过执行opcode识别内部交易，保存内部交易数据。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有交易执行结束，智能合约执行过程重放数据导出存储。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;智能合约执行过程重放优化过程如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;C:Usersczm18Desktop开题报告以太坊交易流程图中文 (1).png&#34; alt=&#34;以太坊交易流程图中文 (1)&#34; /&gt;&lt;/p&gt;

&lt;p&gt;智能合约在虚拟机中的运行过程包含重要信息，对于安全分析和监控尤为重要。在合约任意状态恢复技术的之处下，可复原任意时刻链上状态用于虚拟机跟踪调试，即可用于漏洞追溯分析和威胁检测。本技术还可对关键操作符进行识别，以获取更多核心数据，为后续分析提供尽可能多的深度元信息。&lt;/p&gt;

&lt;p&gt;智能合约的运行模型中还有至关重要的资源机制，用于防止公共系统下的资源滥用。合约运行资源消耗是合约执行过程中的重要部分，同时也对安全分析以及程序质量优化有着重要意义。通过前期索引智能合约的每一步执行操作符，对应资源消耗和剩余情况，可对合约运行时资源进行完整复原，为资源消耗分析和优化建议提供全貌信息。&lt;/p&gt;

&lt;h3 id=&#34;面向区块链的同步缓存技术&#34;&gt;面向区块链的同步缓存技术&lt;/h3&gt;

&lt;p&gt;为了解决区块数据同步和利用过程中，所暴露出来的区别于传统应用数据同步的新问题，本文拟研究节点分叉处理，非活跃数据分离存储方案，热点地址识别策略，实时数据导出等问题。&lt;/p&gt;

&lt;p&gt;区块量系统的基本单位是单一节点，作为分布式系统中的一员与其他节点进行通讯和数据交换。常见的区块链共识机制决定了节点分叉现象不可避免。本文拟研究节点分叉处理技术来处理数据同步时由于分叉带来的数据错位问题。通过建立双层同步缓存区，对于新同步的数据放入第一层缓存区，可供外部进行简单查询分析。当第一层缓存区中相关交易区块确认高度超过规定数值时，认为交易不会被逆转，则推送至第二层缓存区块进一步处理。当分叉发生后，分叉感知模块对第一层缓存区的数据进行更正。这样可以确保进入后续深度分析和持久化存储的数据可靠性。&lt;/p&gt;

&lt;p&gt;区块链中还存在大量非活跃数据，如长期无交易记录的地址以及可能已经作废的智能合约。对于与这类地址相关的数据，本文实施非活跃数据分离存储方案，可以起到缩减核心数据库，提升整体查询分析性能的效果。相对的，对于活跃地址和合约，则优先缓存。具体热点地址识别对象包括：主流项目智能合约，近期热点智能合约，高价值智能合约，关键工具合约。同时，冷热地址会按照一定规则进行重新转换，以达到最高的数据缓存和存储性价比。区块链数据缓存技术主要步骤如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;启动智能合约重放工具Geth-query,Geth-query服务读取全节点数据库LevelDB中的区块数据和区块世界状态快照，恢复重放区块或交易的世界状态。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Geth-query重放智能合约执行过程，过滤虚拟机中特定trace的状态和内部交易，保留最精细的执行过程。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Geth-query重放智能合约执行过程完成，将获取的合约重放的颗粒快照数据导入各个分析模块进行分析处理。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;各个合约数据处理模块如：热点地址识别，节点分叉处理模块和非活跃数据分离等模块对合约重放数据进行处理，将处理过后的数据存入StateDB。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;StateDB触发数据更新，与底层数据库进行冷热数据交换。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体区块链数据缓存架构图如下所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;C:Usersczm18Desktop开题报告以太坊数据存储架构图中文.png&#34; alt=&#34;以太坊数据存储架构图中文&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了满足针对区块链和智能合约的大量数据分析需求，本文研究实时数据导出技术，方便其他场景下的数据二次加工。本文通过更改区块链全节点的源代码，在区块链节点数据同步过程中，对于区块链数据进行实时导出。导出内容可以指定，从而满足不同场景下的需求。&lt;/p&gt;

&lt;h3 id=&#34;工作优越性&#34;&gt;工作优越性&lt;/h3&gt;

&lt;p&gt;完成上述研究后会将产生的结果和现有的全节点RPC接口以及全节点EVM运行速度相互对比，对比主要分为三个方面：&lt;/p&gt;

&lt;p&gt;\1. 对比本地EVM重放智能合约速度和全节点运行智能合约的速度。&lt;/p&gt;

&lt;p&gt;\2. 对比两者RPC请求响应速度，通过对比两者RPC请求响应速度来体现现有工作的优势。&lt;/p&gt;

&lt;p&gt;\3. 对比现有实验结果的RPC请求能够获取的数据而现有全节点的RPC请求不能获取的数据，体现现有工作的优势。比如智能合约运行过程中产生的特征。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
