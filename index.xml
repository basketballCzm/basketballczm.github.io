<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Czm blog</title>
    <link>https://puppym.github.io/blog/</link>
    <description>Recent content on Czm blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 09 Jan 2020 17:24:08 +0800</lastBuildDate>
    
        <atom:link href="https://puppym.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Geth Query并行优化</title>
      <link>https://puppym.github.io/blog/post/geth-query%E5%B9%B6%E8%A1%8C1/geth-query1/</link>
      <pubDate>Thu, 09 Jan 2020 17:24:08 +0800</pubDate>
      
      <guid>https://puppym.github.io/blog/post/geth-query%E5%B9%B6%E8%A1%8C1/geth-query1/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;对于archive模式的全节点完整的跑一次区块大概需要14天(&lt;a href=&#34;https://blog.ethereum.org/2019/07/10/geth-v1-9-0/&#34;&gt;geth v1.9.0&lt;/a&gt;)对于重放合约获取数据该时间较长，并且geth客户端不能定点重放合约，因此需要编写geth-query重放合约工具，并且优化该工具的运行效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对需要重放的区块数量平均分成cpu逻辑内核的份数，然后每一份启动一个协程开始重放区块数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构建一个协程池，协程池内的协程数目为cpu的核数，然后定义一个batchBlockNum，每次向协程池中的空余协程投放batchBlockNum个block。因为每一个协程都在大量读写磁盘，这里使用协程池限制协程数量主要是因为磁盘I/O的限制。这里的运行效率主要和batchBlockNum的大小(CPU计算量的大小)以及使用逻辑核数P的值有关。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于思路1主要是在区块数据中，前面区块数据运行较快，后面区块数据运行慢。通过平分区块数量不能达到平分计算量的效果，因此会导致运行前面区块的协程早已运行完毕，运行后面区块的协程还在继续运行，并且此时CPU的逻辑核没有用完，导致CPU利用效率不高。&lt;/p&gt;
&lt;p&gt;对于思路2，具体分析如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 本机环境&lt;/span&gt;
cpu: K9900 8核16线程
mem: 32G
SSD:4T + 4T
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先将逻辑核数用满16核，三星阵列的读取速度最高位800M每秒左右。然后尝试使用12核发现三星阵列的读取速度也已经跑满，测试600W-610W的速度如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dcvachvmj/image/upload/v1584145870/czm_blog/geth-query%E5%B9%B6%E8%A1%8C%E4%BC%98%E5%8C%96/4_z7bvcx.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面的图显示当P值12及12以上的时候，geth-query的执行效率提升不高，因此600W-610W的g的最优值为12&lt;/p&gt;
&lt;p&gt;对于batchnum大小的衡量如下：&lt;/p&gt;
&lt;h3 id=&#34;进一步工作&#34;&gt;进一步工作&lt;/h3&gt;
&lt;p&gt;由于前面的block世界状态大小较小，对于磁盘读写压力较小，猜想对于前面的块较高P值能够适当提升geth-query执行前面区块的执行效率。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Geth Query报错总结</title>
      <link>https://puppym.github.io/blog/post/geth-query%E6%8A%A5%E9%94%99%E6%80%BB%E7%BB%93/geth-query%E6%8A%A5%E9%94%99%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 09 Jan 2020 17:23:56 +0800</pubDate>
      
      <guid>https://puppym.github.io/blog/post/geth-query%E6%8A%A5%E9%94%99%E6%80%BB%E7%BB%93/geth-query%E6%8A%A5%E9%94%99%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;h2 id=&#34;geth-query报错总结&#34;&gt;Geth-query报错总结&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要介绍Geth-query工具编写过程中的一些问题，特此记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;并发程序文件夹创建失败&#34;&gt;并发程序文件夹创建失败&lt;/h3&gt;
&lt;p&gt;对于对并发程序对于新建一个文件夹，正常逻辑是首先检查一个文件夹是否存在，不存在就创建一个文件夹。但是可能存在一种情况：在检查csv_data目录的时候可能会在检查&lt;code&gt;os.IsNotExist(err)&lt;/code&gt;时候文件不存在，但是&lt;code&gt;os.Mkdir(absDir, 0777)&lt;/code&gt;的时候该&lt;code&gt;csv_data&lt;/code&gt;文件已经由别的协程创建成功，因此writer指针为空。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Stat&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;absDir&lt;/span&gt;); &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;IsNotExist&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;) {
		&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Mkdir&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;absDir&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0777&lt;/span&gt;)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
			&lt;span style=&#34;color:#a6e22e&#34;&gt;Logger&lt;/span&gt;
			&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
		}
	}

	&lt;span style=&#34;color:#a6e22e&#34;&gt;preDir&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;absDir&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;prefix&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Stat&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;preDir&lt;/span&gt;); &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;IsNotExist&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;) {
		&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Mkdir&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;preDir&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0777&lt;/span&gt;)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
			&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
		}
	}

	&lt;span style=&#34;color:#a6e22e&#34;&gt;folderDir&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sprintf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%v/%v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;preDir&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;folderSeq&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;FILE_NUMBER_IN_FOLDER&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;BLOCK_NUMBER_IN_FILE&lt;/span&gt;)
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Stat&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;folderDir&lt;/span&gt;); &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;IsNotExist&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;) {
		&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Mkdir&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;folderDir&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0777&lt;/span&gt;)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
			&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
		}
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;for-range语句循环变量为值传递&#34;&gt;for range语句循环变量为值传递&lt;/h3&gt;
&lt;p&gt;对于情况1能够将&lt;code&gt;transfers&lt;/code&gt;的地址加入切片，情况2将循环局部变量的地址加入切片，情况3新建一个对象将&lt;code&gt;transferTmp&lt;/code&gt;的值赋值给新对象，并且将新对象的地址加入切片。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;transferTmp&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;transfers&lt;/span&gt; {
			&lt;span style=&#34;color:#a6e22e&#34;&gt;transfer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;valueTransfer&lt;/span&gt;)(&lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;transferTmp&lt;/span&gt;))
			&lt;span style=&#34;color:#75715e&#34;&gt;// 1.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#75715e&#34;&gt;// data.transfers = append(data.transfers, (*valueTransfer)(unsafe.Pointer(&amp;amp;transfers[i])))
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#75715e&#34;&gt;// Logger.Infof(&amp;#34;value: %v&amp;#34;, data.transfers[len(data.transfers)-1].value)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#75715e&#34;&gt;// 2.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#75715e&#34;&gt;// data.transfers = append(data.transfers, (*valueTransfer)(unsafe.Pointer(&amp;amp;transfer)))
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;transfers&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;transfers&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;valueTransfer&lt;/span&gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;transfer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;depth&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;transfer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;transactionHash&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;transfer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;transfer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;srcBalance&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;transfer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dest&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;transfer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;destBalance&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;transfer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;transfer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;kind&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;transfer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;snapshot&lt;/span&gt;})
		}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;go-指针内存释放问题&#34;&gt;go 指针内存释放问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;对于全局变量要通过指针保存局部变量的值，最好的办法是将局部变量指针指向的局部地址内容重新new一边，然后赋给全局变量指针。因为局部变量的值在后面可能发生变化。使用全局变量的指针保存局部变量的指针最后全局变量保存的值具有很大的随机性(&lt;strong&gt;全局变量保存局部变量的某一成员指针，局部变量也会被gc释放&lt;/strong&gt;)。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Interpreter&lt;/span&gt;().(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;EVMInterpreter&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;GetConfig&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Tracer&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;StructLogger&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;CaptureTransferState&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StateDB&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StateDB&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;depth&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;common&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Hash&lt;/span&gt;{}, &lt;span style=&#34;color:#a6e22e&#34;&gt;caller&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Address&lt;/span&gt;(),
			&lt;span style=&#34;color:#a6e22e&#34;&gt;to&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Address&lt;/span&gt;(), &lt;span style=&#34;color:#a6e22e&#34;&gt;big&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NewInt&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;Set&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CALL&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StateDB&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StateDB&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;GetNextRevisionId&lt;/span&gt;())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面一段代码中直接保存value的地址，该value地址的值后面可能会发生变化，尽管有指针副本一直指向该处，内存不会释放，但是其值已经改变。具体错误现象是&lt;code&gt;transfer&lt;/code&gt;中的value，只有transactions中的value和gas fee的value是正确的。其余内部交易的value值都是错误的。因为stack中每次push的value值都是从&lt;code&gt;integer = interpreter.intPool.get()&lt;/code&gt;中获取的，该pool中的value值是在动态改变。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;局部指针变量指向一块较大内存，通过全局指针保存。导致一直有指针指向局部分配的较大内存地址，因此大内存一直不能被go的gc释放，导致内存占用过高。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;上述问题是由于captureState函数中新建了一些对象，然后这些对象的指针被保存在全局变量的结构体中，导致go gc工具在释放内存时由于captureState中的对象一直有全局对象指针指向其值，导致其内存一直得不到释放。stack和memory都是一个1024字节的数组，因此其内存一直就是成M的增加，当碰到6810086中的&lt;code&gt;0x68b71d202dc52ad80812b563f3f6b0aaf1f19c04c1260d13055daad5b88a36a8&lt;/code&gt;交易时，其trace数量为100W，导致其内存分配巨大而一直得不到释放。只需将保存stack和memory的部分注释掉即可，因为该部分只要debug打开，该部分会默认加入到structlog的全局变量中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;其它问题&#34;&gt;其它问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;reverTransfer 中的revertNum初始值应该为-1， 避免transfer全部revert掉之后初始值0，还剩余一个transfer。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;selfdestruct中转账的源地址为合约地址，目的地址为stack.pop()出来的地址，注意stack.pop()动作不要为了获取目的地址而执行两遍。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Geth-query获取数据</title>
      <link>https://puppym.github.io/blog/post/geth-query%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/geth-query%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Thu, 09 Jan 2020 14:49:51 +0800</pubDate>
      
      <guid>https://puppym.github.io/blog/post/geth-query%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/geth-query%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</guid>
      
        <description>&lt;h2 id=&#34;geth-query获取数据&#34;&gt;Geth-query获取数据&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;本文承接Geth-query设计文档，主要阐述通过Geth-query功能获得哪些数据，以及怎么获得，需要修改哪些代码。当然Geth-query是一个自定义的合约重放工具，通过修改&lt;code&gt;go-ethereum&lt;/code&gt;的源码以及该工具的代码能够自定义获取任何在EVM中产生过的中间数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;重发智能合约主要要使用&lt;code&gt;achieve&lt;/code&gt;模式全节点的2种数据：1. 区块数据。2.区块的世界状态数据。前者通过&lt;code&gt;achieve&lt;/code&gt;模式全节点通过p2p网络同步获取，后者通过全节点同步过程中通过EVM执行区块数据获取每一个区块的世界状态，然后将两者都通过RLP编码格式进行压缩，存储到底层的levelDB数据库中。&lt;/p&gt;
&lt;p&gt;在重放过程中，获取上述两种数据可以通过&lt;code&gt;go-ethereum&lt;/code&gt;的接口获取。&lt;/p&gt;
&lt;p&gt;获取区块数据&lt;code&gt;block := chain.GetBlockByNumber(currentBlock)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;获取区块世界状态数据&lt;code&gt;statedb, err := blockchain.StateAt(blockchain.GetBlockByHash(block.ParentHash()).Root())&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;执行每笔交易的EVM api接口&lt;code&gt;_, gas, failed, err := core.ApplyMessage(vmenv, msg, gp)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;block数据&#34;&gt;block数据&lt;/h3&gt;
&lt;p&gt;对于区块数据而言，可以直接通过&lt;code&gt;achieve&lt;/code&gt;模式的全节点同步区块数据，然后按照区块数据存入blocks的表中。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;evmType&lt;/th&gt;
&lt;th&gt;pgType&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;blockNumber&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;blockHash&lt;/td&gt;
&lt;td&gt;a hex string&lt;/td&gt;
&lt;td&gt;text (32 byte Keccak256)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;parentHash&lt;/td&gt;
&lt;td&gt;a hex string&lt;/td&gt;
&lt;td&gt;text (32 byte Keccak256)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nonce&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;miner&lt;/td&gt;
&lt;td&gt;a hex string&lt;/td&gt;
&lt;td&gt;text (Address length 20)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;difficulty&lt;/td&gt;
&lt;td&gt;bigint_to_string&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;totalDifficulty&lt;/td&gt;
&lt;td&gt;bigint_to string&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;extraData&lt;/td&gt;
&lt;td&gt;byte[]&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;size&lt;/td&gt;
&lt;td&gt;float64-&amp;gt;string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gasLimit&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gasUsed&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_timestamp&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transactionCount&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;transfers数据&#34;&gt;transfers数据&lt;/h3&gt;
&lt;p&gt;对于transfers数据可以理解为由交易和内部交易导致账户余额世界状态的变化，通过深入修改EVM的源码代码，通过分析EVM在执行合约过程中哪里修改了账户地址的世界状态，然后在该处添加&lt;code&gt;capturetransfers&lt;/code&gt;动作，抓取出每次EVM执行合约过程中账户世界状态变动的transfers数据。下面EVM中的动作导致了账户世界状态的变化：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Call 指令中如果&lt;code&gt;msg.value&lt;/code&gt;的值不为零，并且校验&lt;code&gt;!evm.Context.CanTransfer&lt;/code&gt;校验通过，会进行交易转账或者内部交易转账&lt;code&gt;evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value)&lt;/code&gt;，因此需要在该处添加&lt;code&gt;capturetransfer&lt;/code&gt;动作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;evm.go 240 &lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```golang
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if evm.Interpreter().(*EVMInterpreter).GetConfig().Debug {
evm.Interpreter().(*EVMInterpreter).GetConfig().Tracer.(*StructLogger).CaptureTransferState(evm.StateDB.(*state.StateDB), evm.depth, common.Hash{}, caller.Address(),
to.Address(), value, &amp;ldquo;CALL&amp;rdquo;, evm.StateDB.(*state.StateDB).GetNextRevisionId())
}
```&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create 指令中&lt;code&gt;msg.value&lt;/code&gt;值不为零，并且校验&lt;code&gt;!evm.Context.CanTransfer&lt;/code&gt;校验通过，会导致创建合约过程中给合约账户转账&lt;code&gt;evm.Transfer(evm.StateDB, caller.Address(), address, value)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;这里可能存在一种情况，就是合约hash已经创建成功，但是由于gas费用不足以将合约的code存储进入世界状态会产生&lt;code&gt;ErrCodeStoreOutOfGas&lt;/code&gt;错误，但是此时合约的地址已经存在世界状态中，并且转给合约账户的转账操作也已经生效。&lt;code&gt;evm.go 470&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;evm.go   420&lt;/code&gt;插入&lt;code&gt;capturetransfer&lt;/code&gt;动作&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Interpreter&lt;/span&gt;().(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;EVMInterpreter&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;GetConfig&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Debug&lt;/span&gt; {
		&lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Interpreter&lt;/span&gt;().(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;EVMInterpreter&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;GetConfig&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Tracer&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;StructLogger&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;CaptureTransferState&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StateDB&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StateDB&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;depth&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;common&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Hash&lt;/span&gt;{}, &lt;span style=&#34;color:#a6e22e&#34;&gt;caller&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Address&lt;/span&gt;(),
			&lt;span style=&#34;color:#a6e22e&#34;&gt;address&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CREATE&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StateDB&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StateDB&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;GetNextRevisionId&lt;/span&gt;())
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;selfdestruct指令返回销毁账户的余额。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;instructions.go  881&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;interpreter&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GetConfig&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Debug&lt;/span&gt; {
		&lt;span style=&#34;color:#a6e22e&#34;&gt;interpreter&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GetConfig&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Tracer&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;StructLogger&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;CaptureTransferState&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;interpreter&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StateDB&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StateDB&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;interpreter&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;depth&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;common&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Hash&lt;/span&gt;{}, &lt;span style=&#34;color:#a6e22e&#34;&gt;contract&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Address&lt;/span&gt;(),
			&lt;span style=&#34;color:#a6e22e&#34;&gt;common&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;BigToAddress&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;pop&lt;/span&gt;()), &lt;span style=&#34;color:#a6e22e&#34;&gt;balance&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;selfDestruct&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;interpreter&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StateDB&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StateDB&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;GetNextRevisionId&lt;/span&gt;())
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;区块中每笔交易产生的gas费用会直接在EVM中进行加减，因此在该处应该加入&lt;code&gt;capturetransfers&lt;/code&gt;动作抓取&lt;code&gt;transfer&lt;/code&gt;。注意这里的gas费用值为用户消耗的gas费用值。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;这里计算gas费用也有一些规则：用户首先预支initialGas的上限值，然后在执行合约过程中会逐步消耗gas，但是对于用户的一些操作eth也会奖励用户gas，比如释放storage空间，selfdestruct合约(该操作会退回两笔费用，一笔是gas费用，一笔是合约余额)。最后用户支付的gas费用就是&lt;code&gt;st.initialGas - st.gas&lt;/code&gt;。为了防止用户最后支付的gas费用为负值的情况，用户获得奖励的gas小于或等于用户消耗gas数目的一半。因此在销毁合约获得的奖励可能小于理论值，和用户本次交易消耗的gas有关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​     &lt;code&gt;capturetansfer&lt;/code&gt;动作可以添加在&lt;code&gt;state_transition.go 232行&lt;/code&gt;，具体代码如      下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;st&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Interpreter&lt;/span&gt;().(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;EVMInterpreter&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;GetConfig&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Debug&lt;/span&gt; {
		&lt;span style=&#34;color:#a6e22e&#34;&gt;st&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Interpreter&lt;/span&gt;().(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;EVMInterpreter&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;GetConfig&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Tracer&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StructLogger&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;CaptureTransferState&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;st&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StateDB&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StateDB&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;common&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Hash&lt;/span&gt;{}, &lt;span style=&#34;color:#a6e22e&#34;&gt;msg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;From&lt;/span&gt;(),
			&lt;span style=&#34;color:#a6e22e&#34;&gt;st&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;evm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Coinbase&lt;/span&gt;, new(&lt;span style=&#34;color:#a6e22e&#34;&gt;big&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Int&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;Mul&lt;/span&gt;(new(&lt;span style=&#34;color:#a6e22e&#34;&gt;big&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Int&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;SetUint64&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;st&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;gasUsed&lt;/span&gt;()), &lt;span style=&#34;color:#a6e22e&#34;&gt;st&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;gasPrice&lt;/span&gt;), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;GASFEE&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;叔叔区块奖励和父区块的奖励也是直接在EVM中进行运算，因此也需要加入&lt;code&gt;capturetransfer&lt;/code&gt;动作，该部分在geth-query重放工具中完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;uncle&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;block&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Uncles&lt;/span&gt;() {
		&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;uncle&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Number&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;big8&lt;/span&gt;)
		&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sub&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;block&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Header&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Number&lt;/span&gt;)
		&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Mul&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;blockReward&lt;/span&gt;)
		&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Div&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;big8&lt;/span&gt;)
		&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;transfers&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;transfers&lt;/span&gt;,
			&lt;span style=&#34;color:#a6e22e&#34;&gt;newRewardTransfer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;statedb&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;common&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Hash&lt;/span&gt;{}, &lt;span style=&#34;color:#a6e22e&#34;&gt;common&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Address&lt;/span&gt;{}, &lt;span style=&#34;color:#a6e22e&#34;&gt;uncle&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Coinbase&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UNCLE&amp;#34;&lt;/span&gt;))
		&lt;span style=&#34;color:#a6e22e&#34;&gt;rd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; new(&lt;span style=&#34;color:#a6e22e&#34;&gt;big&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Int&lt;/span&gt;)
		&lt;span style=&#34;color:#a6e22e&#34;&gt;rd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Div&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;blockReward&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;big32&lt;/span&gt;)
		&lt;span style=&#34;color:#a6e22e&#34;&gt;reward&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;reward&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;rd&lt;/span&gt;)
	}

	&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;transfers&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;transfers&lt;/span&gt;,
		&lt;span style=&#34;color:#a6e22e&#34;&gt;newRewardTransfer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;statedb&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;common&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Hash&lt;/span&gt;{}, &lt;span style=&#34;color:#a6e22e&#34;&gt;common&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Address&lt;/span&gt;{}, &lt;span style=&#34;color:#a6e22e&#34;&gt;block&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Coinbase&lt;/span&gt;(), &lt;span style=&#34;color:#a6e22e&#34;&gt;reward&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MINED&amp;#34;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;transfers&lt;/code&gt;表的各项数据如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;evmType&lt;/th&gt;
&lt;th&gt;pgType&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;blockNumber&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;blockHash&lt;/td&gt;
&lt;td&gt;a hex string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_timestamp&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transactionHash&lt;/td&gt;
&lt;td&gt;a hex string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transferIndex&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;depth&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_from&lt;/td&gt;
&lt;td&gt;a hex string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_to&lt;/td&gt;
&lt;td&gt;a hex string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fromBalance&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;toBalance&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transferValue&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transferType&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decollator&lt;/td&gt;
&lt;td&gt;&amp;quot;&amp;rdquo;   -&amp;gt;  string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;transactions数据&#34;&gt;transactions数据&lt;/h3&gt;
&lt;p&gt;transactions数据主要是交易执行完后产生的receipt数据。通过组合&lt;code&gt;get-query&lt;/code&gt;重放合约后的返回值和同步的&lt;code&gt;transactions&lt;/code&gt;数据一起组合形成&lt;code&gt;receipt&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;主要的格式如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;evmType&lt;/th&gt;
&lt;th&gt;pgType&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;text (32 byte Keccak256)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;blockNumber&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;blockHash&lt;/td&gt;
&lt;td&gt;a hex string&lt;/td&gt;
&lt;td&gt;text (32 byte Keccak256)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_timestamp&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transactionHash&lt;/td&gt;
&lt;td&gt;a hex string&lt;/td&gt;
&lt;td&gt;text (32 byte Keccak256)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_from&lt;/td&gt;
&lt;td&gt;a hex string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_to&lt;/td&gt;
&lt;td&gt;a hex string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gas&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gasUsed&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gasPrice&lt;/td&gt;
&lt;td&gt;big.Int&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[]byte&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;logs&lt;/td&gt;
&lt;td&gt;log&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nonce&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;txStr&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;contractAddress&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;error&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decollator&lt;/td&gt;
&lt;td&gt;&amp;quot;&amp;rdquo;&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;traces数据&#34;&gt;traces数据&lt;/h3&gt;
&lt;p&gt;trace包含内容为：CREATE，CALL，CALLCODE，DELEGATECALL，SELFDESTRUCT操作及预编译合约的调用。这里抓取trace的种类可以自定义。该数据的获取通过打开&lt;code&gt;vm.Config&lt;/code&gt;的Debug选项，然后对于每一个trace都会执行&lt;code&gt;captureState&lt;/code&gt;函数捕获每一个trace的相关信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;StructLog&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
	&lt;span style=&#34;color:#a6e22e&#34;&gt;Pc&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64&lt;/span&gt;                      &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;pc&amp;#34;`&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;Op&lt;/span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;OpCode&lt;/span&gt;                      &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;op&amp;#34;`&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;Gas&lt;/span&gt;           &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64&lt;/span&gt;                      &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;gas&amp;#34;`&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;GasCost&lt;/span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64&lt;/span&gt;                      &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;gasCost&amp;#34;`&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;Memory&lt;/span&gt;        []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;                      &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;memory&amp;#34;`&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;MemorySize&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;                         &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;memSize&amp;#34;`&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;Stack&lt;/span&gt;         []&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;big&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Int&lt;/span&gt;                  &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;stack&amp;#34;`&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;Storage&lt;/span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;common&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Hash&lt;/span&gt;]&lt;span style=&#34;color:#a6e22e&#34;&gt;common&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Hash&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;-&amp;#34;`&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;Depth&lt;/span&gt;         &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;                         &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;depth&amp;#34;`&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;RefundCounter&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64&lt;/span&gt;                      &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;refund&amp;#34;`&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;Err&lt;/span&gt;           &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;                       &lt;span style=&#34;color:#e6db74&#34;&gt;`json:&amp;#34;-&amp;#34;`&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在捕获trace的过程中由于stack是一个1M大小的数组，当碰到6810086中的&lt;code&gt;0x68b71d202dc52ad80812b563f3f6b0aaf1f19c04c1260d13055daad5b88a36a8&lt;/code&gt;交易时，其trace数量为100W，因为StructLog中的指针有指向每一个trace中stack的副本，导致其内存分配巨大而一直得不到释放，并行重放区块会直接被卡死，因此在快速重放时一般会屏蔽statck和memory的抓取。发现问题后可以使用单线程抓取某一区块的全部trace信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By using the three main trace types (call, create, suicide), we can generalise the type of ether transfers that can occur:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;call&lt;/strong&gt;: Used to &lt;strong&gt;transfer&lt;/strong&gt; ether from one account to another and/or to call a smart contract function defined by parameters in the data field. This trace also encompasses &lt;strong&gt;delegatecall&lt;/strong&gt; and &lt;strong&gt;callcode&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;create&lt;/strong&gt;: Used to create a smart contract, and ether is &lt;strong&gt;transferred&lt;/strong&gt; to the newly created smart contract&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;suicide&lt;/strong&gt;: Used by an owner of a smart contract to kill the smart contract. Triggers a &lt;strong&gt;transfer&lt;/strong&gt; of ether for a refund for killing a contract. Additionally, killing a smart contract can free memory in the blockchain, which can also affects the value transferred.&lt;/li&gt;
&lt;li&gt;[ethereum-traces-not-transactions-3f0533d26aa](&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;traces数据的格式为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;evmType&lt;/th&gt;
&lt;th&gt;pgType&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;blockHash&lt;/td&gt;
&lt;td&gt;[HashLength]byte&lt;/td&gt;
&lt;td&gt;text (32 byte Keccak256)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;blockHeight&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;txHash&lt;/td&gt;
&lt;td&gt;[HashLength]byte&lt;/td&gt;
&lt;td&gt;text (32 byte Keccak256)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;txIndex&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pc&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;op&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;depth&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;bignint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;refundCounter&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;precompiled&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;err&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decollator&lt;/td&gt;
&lt;td&gt;&amp;quot;&amp;rdquo;&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;events数据&#34;&gt;events数据&lt;/h3&gt;
&lt;p&gt;events数据主要是用来分析&lt;code&gt;ERC20 token&lt;/code&gt;的转账情况，因为根据&lt;code&gt;ERC 20&lt;/code&gt;规范每一笔转账操作都会产生一个event事件。events数据主要通过交易执行之后产生的receipt.logs来获取。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;receipt.Logs = statedb.GetLogs(tx.Hash())&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;id = blockNumber*10^5 + idx&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;evmType&lt;/th&gt;
&lt;th&gt;pgType&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;eventAddress&lt;/td&gt;
&lt;td&gt;[AddressLength]byte   a hex string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;topics&lt;/td&gt;
&lt;td&gt;[]byte -&amp;gt; string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;eventData&lt;/td&gt;
&lt;td&gt;[]byte -&amp;gt; string&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;blockNumber&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transactionHash&lt;/td&gt;
&lt;td&gt;[HashLength]byte&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transactionIndex&lt;/td&gt;
&lt;td&gt;uint&lt;/td&gt;
&lt;td&gt;bignint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;blockHash&lt;/td&gt;
&lt;td&gt;[HashLength]byte&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;logIndex&lt;/td&gt;
&lt;td&gt;uint&lt;/td&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;removed&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decollator&lt;/td&gt;
&lt;td&gt;&amp;quot;&amp;rdquo;&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;其它数据&#34;&gt;其它数据&lt;/h3&gt;
&lt;p&gt;geth-query工具可以自定义导出数据，根据哪些数据具备分析价值可以通过修改工具代码或者&lt;code&gt;go-ethereum&lt;/code&gt;代码进行导出数据分析。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于合约运行失败的交易统计，可以从以下几个方面统计：交易失败类型统计(柱状图)，交易失败数目统计(折线图，每1W个块或者10W个块为单位)。&lt;/li&gt;
&lt;li&gt;trace数量由前面的块到后面的块，交易的trace数量逐步递增的曲线。&lt;/li&gt;
&lt;li&gt;交易消耗的gas分析。&lt;/li&gt;
&lt;li&gt;热点合约的分析。&lt;/li&gt;
&lt;li&gt;交易地址的网络图。&lt;/li&gt;
&lt;li&gt;交易运行特征trace分析。&lt;/li&gt;
&lt;li&gt;所有历史交易随时间变化trace数量的调用关系。&lt;/li&gt;
&lt;li&gt;交易执行高频trace，低频trace。&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Go Sheduler</title>
      <link>https://puppym.github.io/blog/post/go-scheduler/go-scheduler/</link>
      <pubDate>Sat, 04 Jan 2020 16:21:44 +0800</pubDate>
      
      <guid>https://puppym.github.io/blog/post/go-scheduler/go-scheduler/</guid>
      
        <description>&lt;h2 id=&#34;go-调度器&#34;&gt;go 调度器&lt;/h2&gt;
&lt;h3 id=&#34;介绍&#34;&gt;介绍&lt;/h3&gt;
&lt;p&gt;Go 1.1的最重要的一个特性是引入了新的调度器，由Dmitry Vyukov贡献， 新的调度器极大的提高了程序的并行性能。&lt;/p&gt;
&lt;h3 id=&#34;go-runtime需要一个怎样的调度器&#34;&gt;go runtime需要一个怎样的调度器？&lt;/h3&gt;
&lt;p&gt;但是在查看新的调度器之前，我们需要了解为什么需要它。当操作系统可以为您调度线程时为什么需要创建用户进空间的线程（goroutine）?&lt;/p&gt;
&lt;p&gt;POSIX线程API是现有Unix进程模型的逻辑扩展，因此，线程可以获得与进程相同的许多控件。线程有自己的信号掩码，可以分配CPU亲缘关系，可以放在cgroups中，可以查询它们使用哪些资源。所有这些控件都为Go程序使用goroutines所不需要的功能增加了开销，当程序中有100,000个线程时，这些开销就会迅速增加。&lt;/p&gt;
&lt;p&gt;另一个问题是，基于Go模型操作系统无法做出明智的调度决策。例如，Go垃圾收集器要求在运行收集动作时停止所有线程，并且内存必须处于一致的状态。这涉及到等待正在运行的线程到达一个内存是一致的点。&lt;/p&gt;
&lt;p&gt;当您在一个随机时间点调度许多线程时，很可能需要等待许多线程达到一致的状态。Go调度器只能在内存是一致的地方进行调度。这意味着，当我们停止垃圾收集动作时，我们不得不取等待正在CPU核上积极运行的线程。&lt;/p&gt;
&lt;p&gt;通常有3个线程模型。一个是N:1，其中几个用户空间线程在一个OS线程上运行。这样做的优点是可以非常快速地切换上下文，但是不能利用多核系统。另一个是1:1，其中一个执行线程与一个操作系统线程匹配，它利用了机器上的所有核心，但是上下文切换很慢，因为上下文的切换也就是物理线程的切换，需要操作系统的介入。&lt;/p&gt;
&lt;p&gt;Go试图通过使用M:N调度器来同时利用这两个方面。它将任意数量的goroutine调度到任意数量的OS线程上。您可以快速切换上下文，并利用系统中的所有核心。这种方法的主要缺点是它增加了调度器的复杂性。&lt;/p&gt;
&lt;h3 id=&#34;go-scheduler-组成&#34;&gt;go-scheduler 组成&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;为了完成调度任务，Go调度器使用3个主要实体&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;G: goroutine包含堆栈，指令指针和其他协程调度的重要信息，比如任何可能被阻塞的channel。在runtime的代码中它被称为G。&lt;/p&gt;
&lt;p&gt;P: 逻辑处理器Processor，其代表调度的上下文，您可以将它看作是在单个线程上运行Go代码的调度程序的本地化版本。P是重要的对于让我们从老版本的GM模式的N:1转换到GPM模式的M:N（协程：物理线程）。在runtime中他被称为P，p的值可以被 &lt;code&gt;GOMAXPROCS()&lt;/code&gt;函数所设置。&lt;/p&gt;
&lt;p&gt;M: M是直接被OS调度管理的物理线程，它非常像标准的POSIX线程。在runtime中，它被称为M for Machine。&lt;/p&gt;
&lt;p&gt;下面的图可以表示其3者者之间的关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://morsmachine.dk/in-motion.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上面我们看到2个线程(M)，每个M都有一个context(P)和一个正在运行的goroutine(G)。为了运行G，一个M必须拥有一个P。&lt;/p&gt;
&lt;p&gt;P的数量可以用环境变量GOMAXPROCS和runtime中的&lt;code&gt;GOMAXPROCS()&lt;/code&gt;函数来设置，正常来说该值不会被改变。并且在go语言后面的版本中该值固定为CPU的逻辑核数。&lt;/p&gt;
&lt;p&gt;灰色的协程没有被运行，但是它准备被调度，他们被排列在runqueues队列中， 该队列采用FIFO的进出方式。当协程执行go语句时，它被放到runqueues的结尾，P会运行一个协程直到到达调度时间点，然后P会从runqueue队列中取出G，然后设置栈和指令指针开始运行协程。&lt;/p&gt;
&lt;p&gt;为了降低由多个P的情况下对于runqueue的互斥争用情况，每一个P都有自己的local runqueue。在之前的版本中go的调度器仅仅只有一个全局的runqueue，并且用一个互斥锁来保护它。线程经常会为了等待runqueue的互斥锁而被阻塞。当你想充分利用一个32核心机器上的计算资源时，这会变得更加糟糕。&lt;/p&gt;
&lt;p&gt;只要所有上下文都有goroutines要运行，调度器就会在这种稳定状态下继续调度。然而，有两个场景可以改变这种情况。&lt;/p&gt;
&lt;h4 id=&#34;syscall&#34;&gt;syscall&lt;/h4&gt;
&lt;p&gt;你可能会想，为什么要有P呢?我们不能把runqueue放到线程M上，然后去掉上下文P吗?我们有上下文P的原因是，如果正在运行的线程由于某种原因需要阻塞，我们可以将它们传递给其他线程。&lt;/p&gt;
&lt;p&gt;一个线程可能阻塞的例子是当我们调用一个系统调用时，线程可能会被阻塞在syscall上，因此在线程M阻塞时，应该传递上下文P，使得它能够继续调度其余G。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://morsmachine.dk/syscall.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上面的图中，我们看到一个线程M0放弃了上下文P，以便另外一个线程M1能够运行该上下文。go调度器确保有足够的线程来运行上下文P。上面例子中的M1可能只是为了处理这个syscall而创建的，也可能来自线程的缓存(线程复用)。syscall线程M0将保持协程G0一直处理系统调用，G0尽管被阻塞了，但是从技术的角度来说它任然在执行。&lt;/p&gt;
&lt;p&gt;当syscall返回时，为了运行返回的goroutine，线程必须尝试获取一个上下文P。正常的操作模式是从其他线程之一窃取上下文P。如果它不能窃取一个，它将把goroutine放到一个全局运行队列中，把自己放到线程缓存中，然后休眠。&lt;/p&gt;
&lt;p&gt;上下文P的本地运行队列取出G取完后会到全局运行队列中去取。上下文P还会定期检查全局运行队列中的goroutines。否则，全局运行队列上的goroutines可能会因为饥饿而停止运行。&lt;/p&gt;
&lt;p&gt;这种对系统调用的处理就是为什么Go程序能够运行多个线程，即使GOMAXPROCS为1。runtime来用goroutines通过线程进行系统调用，线程阻塞时，就将线程放在一边。&lt;/p&gt;
&lt;h4 id=&#34;stealing-work&#34;&gt;Stealing work&lt;/h4&gt;
&lt;p&gt;go调度系统稳定状态改变的另一种方式是当上下文P耗尽了要调度的goroutines时，如果上下文P的运行队列上的G数量不平衡，这将导致有的上下文P耗尽了它的运行队列，但是系统中仍然有工作要做。为了继续高效的运行代码，上下文P首先将从全局队列中获取G，如果当中没有G，它会从其余上下文P中取一半的G，这确保了每一个上下文P都是处于工作状态以及所有线程都在以最大容量G工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://morsmachine.dk/steal.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;总结上面调度器为了达到平衡状态而做的两个动作。syscall可以总结当G导致M阻塞时，P向下抛弃M。steal work可以总结为P执行完所有G后，从全局运行队列和其余P中调度一半G。&lt;/p&gt;
&lt;h3 id=&#34;goroutine-调度&#34;&gt;goroutine 调度&lt;/h3&gt;
&lt;p&gt;Go运行时会在下面的goroutine被阻塞的情况下运行另外一个goroutine。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;blocking syscall(for example opening a file)&lt;/li&gt;
&lt;li&gt;network input&lt;/li&gt;
&lt;li&gt;channel operations&lt;/li&gt;
&lt;li&gt;primitives in the sync package&lt;/li&gt;
&lt;li&gt;The Go statement, although there is no guarantee that new goroutine will be scheduled immediately.&lt;/li&gt;
&lt;li&gt;After being stopped for a garbage collection cycle.&lt;a href=&#34;https://codeburst.io/why-goroutines-are-not-lightweight-threads-7c460c1f155f&#34;&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;sysmon&#34;&gt;sysmon&lt;/h3&gt;
&lt;p&gt;sysmon是一个由runtime启动的M，也叫监控线程，它无需P也可以运行，它每20us~10ms唤醒一次，主要执行:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;释放闲置超过5分钟的span物理内存； scavenge heap&lt;/li&gt;
&lt;li&gt;如果超过2分钟没有垃圾回收，强制执行；forcegc&lt;/li&gt;
&lt;li&gt;将长时间未处理的netpoll结果添加到任务队列；netpool&lt;/li&gt;
&lt;li&gt;向长时间运行的G任务发出抢占调度；retake&lt;a href=&#34;http://xiaorui.cc/2018/06/04/golang%e5%af%86%e9%9b%86%e5%9c%ba%e6%99%af%e4%b8%8b%e5%8d%8f%e7%a8%8b%e8%b0%83%e5%ba%a6%e9%a5%a5%e9%a5%bf%e9%97%ae%e9%a2%98/&#34;&gt;golang-Cpu密集型任务调度抢占&lt;/a&gt;。这里发生抢占其实是一种伪抢占，本质上是sysmon中的retake触发morestack，然后调用newstack，然后gopreempt_m会重置g的状态，并且扔到全局runq中重新进行调度(这里扔到全局的runq中也比较好理解，因为全局队列中都是一些需要执行时间比较长的G，中心思想是全局runq中的G执行时间比本地runq执行时间要长)。&lt;/li&gt;
&lt;li&gt;收回因syscall长时间阻塞的P；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;go调度器还有很多细节，比如cgo线程LockOSThread()函数以及与网络轮询器的集成。这些都能够在go的runtime库中能够找到。&lt;/p&gt;
&lt;h4 id=&#34;参考&#34;&gt;参考&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://morsmachine.dk/go-scheduler&#34;&gt;go-scheduler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://wudaijun.com/2018/01/go-scheduler/&#34;&gt;go-scheduler1&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Geth-query</title>
      <link>https://puppym.github.io/blog/post/geth-query/geth-query/</link>
      <pubDate>Thu, 02 Jan 2020 09:41:04 +0800</pubDate>
      
      <guid>https://puppym.github.io/blog/post/geth-query/geth-query/</guid>
      
        <description>&lt;h2 id=&#34;以太坊智能合约数据高速抽取和重放&#34;&gt;以太坊智能合约数据高速抽取和重放&lt;/h2&gt;
&lt;p&gt;为了解决从海量的区块数据中快速提取智能合约运行特征，本文提出智能合约数据快速抽取和重放技术。解决以太坊从海量区块数据中抽取合约运行状态难和利用合约运行状态实时监控合约状态难的问题。主要的分为以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;智能合约状态的自动抽取。智能&lt;/li&gt;
&lt;li&gt;合约再链上执行过程中，每一个状态都有可能导致其世界状态的变化。在同步区块数据时，通过适当保存合约运行的中间状态，能够实现智能合约的定点重放。&lt;/li&gt;
&lt;li&gt;智能合约执行过程的快速重放。通过优化本地的EVM，更改EVM的内部结构，通过EVM快速重发智能合约以及抽取合约运行特征。&lt;/li&gt;
&lt;li&gt;面向区块链的同步缓存技术。通过存储智能合约重发运行特征以及区块数据，并且提供高效的外部查询接口。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;智能合约状态的自动抽取&#34;&gt;智能合约状态的自动抽取&lt;/h3&gt;
&lt;p&gt;智能合于运行在区块链虚拟环境中，不存在直观的标准化接口能够访问合约中的各类状态。事实上，单一合约状态的变化会影响整个区块链状态的变化，而且这种变化会随着区块高度和交易数量而不断增加，甚至随着合约代码的逐步调用执行而时刻发生变化。例如，合约的单步执行即可导致自身状态变化，或导致多个账户余额更改，或导致其他合约的状态发生变化。因此为了快速定位需要的信息，高效筛选合约状态至关重要，本部分通过对智能合约特性深入分析，筛选出不同维度的链上信息进行处理和快照，如区块，交易，收据，事件日志，合约基本全貌信息，特定类型合约信息，合约内部调用记录，合约逐步调用轨迹等。这些信息从粗至细记录了合约在链上的所有状态，可以满足不同场景下的分析需求。&lt;/p&gt;
&lt;p&gt;智能合约数据抽取过程具体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过以太坊Geth客户端启动全节点，全节点会启动一系列服务，P2P服务从其他以太坊全节点通过P2P连接同步区块数据到内存。&lt;/li&gt;
&lt;li&gt;Geth客户端按区块顺序遍历执行每个区块和区块中的每一笔交易，在执行过程中快照保存每个区块的世界状态和智能合约数据存储的中间状态，便于通过快照状态重放智能合约。&lt;/li&gt;
&lt;li&gt;每笔交易的执行会对应一个新的EVM虚拟机，EVM虚拟机通过合约账户的code域按顺序读取智能合约的opcode指令执行，快照保存指定opcode执行状态，通过执行opcode识别内部交易，保存内部交易数据。&lt;/li&gt;
&lt;li&gt;交易执行结束，保存交易数据，以及交易返回的票据数据。&lt;/li&gt;
&lt;li&gt;区块执行结束，保存区块数据，向底层levelDB数据库commit数据更新。&lt;/li&gt;
&lt;li&gt;重复上述操作，直至全节点跟上主网的同步状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dcvachvmj/image/upload/v1584145931/czm_blog/geth-query/1_zq1ezz.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;另一方面，合约状态和区块交易中还包含大量冗余信息，对长期数据存储同步以及后续分析带来极大的压力，后面会对数据使用颗粒化快照策略，对这部分信息进行过滤。&lt;/p&gt;
&lt;h3 id=&#34;智能合约执行过程重放优化&#34;&gt;智能合约执行过程重放优化&lt;/h3&gt;
&lt;p&gt;针对智能合约依赖特定运行环境以及合约状态时间依赖问题，本文研究合约任意状态恢复，合约虚拟机跟踪调试，合约运行资源消耗复原。&lt;/p&gt;
&lt;p&gt;智能合约和区块链本质上是一个状态机系统，智能合约的逐步执行造成状态的改变和转移。本文通过记录区块链每个区块下的状态，以及在交易维度下的每次状态差异，实现最小代价维护整个区块链系统的关键状态转移信息。另外，通过索引每个交易trace和交易内的虚拟机执行trace,保留最精细的执行过程信息。这种设计下，可以实现以下多维度的执行过程重发：任意区块内的所有交易执行重放；任意交易的执行过程重放；任意合约执行过程中虚拟机状态重放。前面提到记录的每次状态差异即可用于快速对比合约执行效果，也用于高效复原任意节点的完整合约状态。最终通过此套方案快速恢复智能合约在历史上任意时刻的状态。并且由于对EVM进行了优化，通过过滤关键的trace信息和去除交易执行完后向底层数据库LevelDB的写操作，能够极大加快EVM重放交易的速度。智能合约执行过程重发执行步骤主要如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;启动智能合约重放工具Geth-query,Geth-query服务读取全节点数据库LevelDB中的区块数据和区块世界状态快照，恢复重放区块或交易的世界状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Geth-query服务按区块顺序遍历执行每个区块和区块中的每一笔交易，通过对每一笔交易都新建一个EVM虚拟机开始执行交易。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EVM虚拟机通过合约账户的code域按顺序读取智能合约的opcode指令执行，快照保存指定opcode执行状态，通过执行opcode识别内部交易，保存内部交易数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有交易执行结束，智能合约执行过程重放数据导出存储。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;智能合约执行过程重放优化过程如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dcvachvmj/image/upload/v1584145929/czm_blog/geth-query/2_o0ptdq.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;智能合约在虚拟机中的运行过程包含重要信息，对于安全分析和监控尤为重要。在合约任意状态恢复技术的之处下，可复原任意时刻链上状态用于虚拟机跟踪调试，即可用于漏洞追溯分析和威胁检测。本技术还可对关键操作符进行识别，以获取更多核心数据，为后续分析提供尽可能多的深度元信息。&lt;/p&gt;
&lt;p&gt;智能合约的运行模型中还有至关重要的资源机制，用于防止公共系统下的资源滥用。合约运行资源消耗是合约执行过程中的重要部分，同时也对安全分析以及程序质量优化有着重要意义。通过前期索引智能合约的每一步执行操作符，对应资源消耗和剩余情况，可对合约运行时资源进行完整复原，为资源消耗分析和优化建议提供全貌信息。&lt;/p&gt;
&lt;h3 id=&#34;面向区块链的同步缓存技术&#34;&gt;面向区块链的同步缓存技术&lt;/h3&gt;
&lt;p&gt;为了解决区块数据同步和利用过程中，所暴露出来的区别于传统应用数据同步的新问题，本文拟研究节点分叉处理，非活跃数据分离存储方案，热点地址识别策略，实时数据导出等问题。&lt;/p&gt;
&lt;p&gt;区块量系统的基本单位是单一节点，作为分布式系统中的一员与其他节点进行通讯和数据交换。常见的区块链共识机制决定了节点分叉现象不可避免。本文拟研究节点分叉处理技术来处理数据同步时由于分叉带来的数据错位问题。通过建立双层同步缓存区，对于新同步的数据放入第一层缓存区，可供外部进行简单查询分析。当第一层缓存区中相关交易区块确认高度超过规定数值时，认为交易不会被逆转，则推送至第二层缓存区块进一步处理。当分叉发生后，分叉感知模块对第一层缓存区的数据进行更正。这样可以确保进入后续深度分析和持久化存储的数据可靠性。&lt;/p&gt;
&lt;p&gt;区块链中还存在大量非活跃数据，如长期无交易记录的地址以及可能已经作废的智能合约。对于与这类地址相关的数据，本文实施非活跃数据分离存储方案，可以起到缩减核心数据库，提升整体查询分析性能的效果。相对的，对于活跃地址和合约，则优先缓存。具体热点地址识别对象包括：主流项目智能合约，近期热点智能合约，高价值智能合约，关键工具合约。同时，冷热地址会按照一定规则进行重新转换，以达到最高的数据缓存和存储性价比。区块链数据缓存技术主要步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;启动智能合约重放工具Geth-query,Geth-query服务读取全节点数据库LevelDB中的区块数据和区块世界状态快照，恢复重放区块或交易的世界状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Geth-query重放智能合约执行过程，过滤虚拟机中特定trace的状态和内部交易，保留最精细的执行过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Geth-query重放智能合约执行过程完成，将获取的合约重放的颗粒快照数据导入各个分析模块进行分析处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各个合约数据处理模块如：热点地址识别，节点分叉处理模块和非活跃数据分离等模块对合约重放数据进行处理，将处理过后的数据存入StateDB。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;StateDB触发数据更新，与底层数据库进行冷热数据交换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体区块链数据缓存架构图如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dcvachvmj/image/upload/v1584145926/czm_blog/geth-query/3_b5fv1e.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;为了满足针对区块链和智能合约的大量数据分析需求，本文研究实时数据导出技术，方便其他场景下的数据二次加工。本文通过更改区块链全节点的源代码，在区块链节点数据同步过程中，对于区块链数据进行实时导出。导出内容可以指定，从而满足不同场景下的需求。&lt;/p&gt;
&lt;h3 id=&#34;工作优越性&#34;&gt;工作优越性&lt;/h3&gt;
&lt;p&gt;完成上述研究后会将产生的结果和现有的全节点RPC接口以及全节点EVM运行速度相互对比，对比主要分为三个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对比本地EVM重放智能合约速度和全节点运行智能合约的速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对比两者RPC请求响应速度，通过对比两者RPC请求响应速度来体现现有工作的优势。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对比现有实验结果的RPC请求能够获取的数据而现有全节点的RPC请求不能获取的数据，体现现有工作的优势。比如智能合约运行过程中产生的特征。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://puppym.github.io/blog/post/%E5%9B%BD%E5%AF%86%E7%AC%94%E8%AE%B0/%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://puppym.github.io/blog/post/%E5%9B%BD%E5%AF%86%E7%AC%94%E8%AE%B0/%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      
        <description>&lt;h1 id=&#34;国密算法学习笔记&#34;&gt;国密算法学习笔记&lt;/h1&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&#34;1概述&#34;&gt;1.概述&lt;/h2&gt;
&lt;p&gt;国密算法是国家商用密码算法的简称。自 2012 年以来，国家密码管理局以《中华人民共和国密码行业标准》的方式，陆续公布了 SM2/SM3/SM4 等密码算法标准及其应用规范。其中“SM”代表“商密”，即用于商用的、不涉及国家秘密的密码技术。[1]&lt;/p&gt;
&lt;p&gt;国密规范标准文件列表：http://www.gmbz.org.cn/main/bzlb.html&lt;/p&gt;
&lt;h2 id=&#34;2sm2&#34;&gt;2.SM2&lt;/h2&gt;
&lt;h3 id=&#34;21-简介&#34;&gt;2.1. 简介&lt;/h3&gt;
&lt;p&gt;SM2 为基于椭圆曲线密码的公钥密码算法标准，包含数字签名、密钥交换和公钥加密，用于替换 RSA/Diffie-Hellman/ECDSA/ECDH 等国际算法。其&lt;/p&gt;
&lt;p&gt;私钥长度：32字节。&lt;/p&gt;
&lt;p&gt;公钥长度：SM2非压缩公钥格式字节串长度为65字节，压缩格式长度为33字节，若公钥y坐标最后一位为0，则首字节为&lt;code&gt;0x02&lt;/code&gt;，否则为&lt;code&gt;0x03&lt;/code&gt;。非压缩格式公钥首字节为&lt;code&gt;0x04&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;签名长度：64字节。&lt;/p&gt;
&lt;h3 id=&#34;22-椭圆曲线及参数&#34;&gt;2.2. 椭圆曲线及参数&lt;/h3&gt;
&lt;h4 id=&#34;221-基础概念&#34;&gt;2.2.1 基础概念&lt;/h4&gt;
&lt;h5 id=&#34;2211--群&#34;&gt;2.2.1.1  群&lt;/h5&gt;
&lt;p&gt;数学意义上的&lt;strong&gt;群&lt;/strong&gt;是一个集合和定义在这个集合上的二元运算，我们不妨把这个二元运算称之为“加法”，并用符号+表示。为了使集合G成为一个群，我们必须定义加法（区别于算术加法），使其服从以下四个性质:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;封闭性：如果a和b都属于G，则a+b也属于G；&lt;/li&gt;
&lt;li&gt;结合律：对于G中的任意元素a、b和c，都有（a+b）+c=a+（b+c）成立；&lt;/li&gt;
&lt;li&gt;单位元：G中存在单位元0，对于G中任意元素a，都有a+0=0+a=a成立&lt;/li&gt;
&lt;li&gt;逆元：对于G中任意元素a，G中都存在元素b，使得a+b=b+a=0成立。G就叫作一个群，记为（G，+）
如果我们加上第五个属性：&lt;/li&gt;
&lt;li&gt;交换律：a+b=b+a
这样的群被称作交换群（Abel群）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用通常的算术加法概念，整数Z的集合是一个群(此外，它是一个交换群)。然而，自然数N的集合不是一个群，因为第四个性质不能被满足。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;椭圆曲线上的群&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该群的元素是椭圆曲线上的点；&lt;/li&gt;
&lt;li&gt;单位元是无穷远处的点0&lt;/li&gt;
&lt;li&gt;点P的逆元是椭圆曲线上关于x轴对称的点；&lt;/li&gt;
&lt;li&gt;加法由以下规则给出:给定三个在一条直线上的非零点P、Q和R，它们的和为P+Q+R=0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;定义在椭圆曲线上群的加法运算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在椭圆曲线上，我们将加法群和曲线对应为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;我们将&lt;strong&gt;曲线上的点&lt;/strong&gt;对应到群上的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;单位元素定义&lt;/strong&gt;为曲线上的无穷大处的点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;点P的逆元&lt;/strong&gt;，表示为关于x轴对称的点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;加法定义&lt;/strong&gt;为：给定曲线上三个点P, Q, R，三个点在一个直线上，使得 P + Q + R = 0现在我们推导一下 P + Q + R = 0， 所以 P + Q = -R, 在图像上表示为 R，关于 x 轴的对称点：&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=P+%3D+%28x_P%2C+y_P%29%2C+Q+%3D+%28x_Q%2C+y_Q%29&#34; alt=&#34;[公式]&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果P和Q不是同一个点，我们可以计算两点连线的斜率&lt;img src=&#34;https://www.zhihu.com/equation?tex=m+%3D+%5Cfrac%7By_P+-+y_Q%7D%7Bx_P+-+x_Q%7D&#34; alt=&#34;[公式]&#34;&gt;&lt;/p&gt;
&lt;p&gt;这条线与椭圆曲线的交点是第三点&lt;img src=&#34;https://www.zhihu.com/equation?tex=R+%3D+%28x_R%2C+y_R%29+%5Cbegin%7Barray%7D%7Brcl%7D+++++x_R+%26+%3D+%26+m%5E2+-+x_P+-+x_Q+%5C%5C+++++y_R+%26+%3D+%26+y_P+%2B+m%28x_R+-+x_P%29+%5Cend%7Barray%7D&#34; alt=&#34;[公式]&#34;&gt;&lt;/p&gt;
&lt;p&gt;或者等价的有： &lt;img src=&#34;https://www.zhihu.com/equation?tex=y_R+%3D+y_Q+%2B+m%28x_R+-+x_Q%29&#34; alt=&#34;[公式]&#34;&gt;&lt;/p&gt;
&lt;p&gt;最终我们有： &lt;img src=&#34;https://www.zhihu.com/equation?tex=%28x_P%2C+y_P%29+%2B+%28x_Q%2C+y_Q%29+%3D+%28x_R%2C+-y_R%29&#34; alt=&#34;[公式]&#34;&gt;&lt;/p&gt;
&lt;p&gt;注意符号，P + Q = - R，即使P或Q中的一个是切点，上述方程也是有效的。&lt;/p&gt;
&lt;p&gt;P=Q的情况需要有一点不同的处理: 计算 &lt;img src=&#34;https://www.zhihu.com/equation?tex=x_R&#34; alt=&#34;[公式]&#34;&gt; 和 &lt;img src=&#34;https://www.zhihu.com/equation?tex=y_R&#34; alt=&#34;[公式]&#34;&gt; 的方程是相同的，但是考虑到 &lt;img src=&#34;https://www.zhihu.com/equation?tex=x_P%3Dx_Q&#34; alt=&#34;[公式]&#34;&gt; ，我们要重新计算斜率（实际上就是过P点的切线斜率）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=m+%3D+%5Cfrac%7B3+x_P%5E2+%2B+a%7D%7B2+y_P%7D&#34; alt=&#34;[公式]&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面的两种情况在写代码是由要注意区分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义在椭圆曲线上群的乘法运算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了加法，我们可以定义另一种运算:标量乘法，即:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=nP+%3D+%5Cunderbrace%7BP+%2B+P+%2B+%5Ccdots+%2B+P%7D_%7Bn%5C+%5Ctext%7Btimes%7D%7D&#34; alt=&#34;[公式]&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是该中标量乘法，那么我们的算法复杂度是 &lt;img src=&#34;https://www.zhihu.com/equation?tex=O%282%5Ek%29&#34; alt=&#34;[公式]&#34;&gt; ，效率不是很高。&lt;/p&gt;
&lt;p&gt;介绍了一种更快的计算标量乘法的算法，通过将n转化为二进制形式，例如&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Brcl%7D+++++151+%26+%3D+%26+1+%5Ccdot+2%5E7+%2B+0+%5Ccdot+2%5E6+%2B+0+%5Ccdot+2%5E5+%2B+1+%5Ccdot+2%5E4+%2B+0+%5Ccdot+2%5E3+%2B+1+%5Ccdot+2%5E2+%2B+1+%5Ccdot+2%5E1+%2B+1+%5Ccdot+2%5E0+%5C%5C+++++%26+%3D+%26+2%5E7+%2B+2%5E4+%2B+2%5E2+%2B+2%5E1+%2B+2%5E0+%5Cend%7Barray%7D&#34; alt=&#34;[公式]&#34;&gt;&lt;/p&gt;
&lt;p&gt;这样我们计算 &lt;img src=&#34;https://www.zhihu.com/equation?tex=151+%5Ccdot+P&#34; alt=&#34;[公式]&#34;&gt; 时，可以转化成如下形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=151+%5Ccdot+P+%3D+2%5E7+P+%2B+2%5E4+P+%2B+2%5E2+P+%2B+2%5E1+P+%2B+2%5E0+P&#34; alt=&#34;[公式]&#34;&gt;&lt;/p&gt;
&lt;p&gt;优化后的算法复杂度是 &lt;img src=&#34;https://www.zhihu.com/equation?tex=O%28log%5C%2Cn%29&#34; alt=&#34;[公式]&#34;&gt; ，如果考虑n的二进制位数k，算法的复杂度是 &lt;img src=&#34;https://www.zhihu.com/equation?tex=O%28k%29&#34; alt=&#34;[公式]&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;2212-有限域&#34;&gt;2.2.1.2 有限域&lt;/h5&gt;
&lt;p&gt;有限域 $$F_q$$，其中 q 是一个奇素数或是 2 的幂：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;（素域）当 q 为奇素数时，$$q=p$$，表示为 $$F_p$$，其中 $$p &amp;gt; 2^{191}$$&lt;/li&gt;
&lt;li&gt;（二元扩域）当 q 为 2 的幂，$$q=2^m$$，表示为 $$F_{2^m}$$，其中 $$m&amp;gt;192 $$ 且为素数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有限域 $$F_q$$必须是一个包含有限数量元素的集合。有限域的一个例子就是模p的整数集，其中p是素数。在域中我们需要定义加法(+)和乘法(*)的二元运算，两者都满足封闭性，结合律和交换律。对于这两个操作，每个元素都有一个唯一的单位元，一个唯一的逆元。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有限域的一个实例就是模质数p的整数集$$F_p$$，它是定义在整数集$${0,1,2&amp;hellip;p-1}$$上。$$F_p$$的加法和乘法分别就是模加法和模乘法，$$F_{23}$$的一些操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;请注意，这里的 &lt;img src=&#34;https://www.zhihu.com/equation?tex=p&#34; alt=&#34;[公式]&#34;&gt; 必须是一个质数！模4整数集就不是一个域: 因为2没有乘法逆(即等式 &lt;img src=&#34;https://www.zhihu.com/equation?tex=2+%5Ccdot+x+%5Cbmod%7B4%7D+%3D+1&#34; alt=&#34;[公式]&#34;&gt; 没有解)。&lt;/p&gt;
&lt;p&gt;有限域中的除法可以通过利用&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Extended_Euclidean_algorithm&#34;&gt;扩展欧几里德算法&lt;/a&gt;可以“轻松”地计算乘法逆元，在最坏的情况下，算法的时间复杂度是 &lt;img src=&#34;https://www.zhihu.com/equation?tex=O%28%5Clog+p%29&#34; alt=&#34;[公式]&#34;&gt; (或者 &lt;img src=&#34;https://www.zhihu.com/equation?tex=O%28k+%29&#34; alt=&#34;[公式]&#34;&gt; ，如果我们考虑p的比特长度的话)。本质上我们可以认为 &lt;img src=&#34;https://www.zhihu.com/equation?tex=x+%2F+y+%3D+x+%5Ccdot+y%5E%7B-1%7D&#34; alt=&#34;[公式]&#34;&gt; ，即把x除以y看成是x乘上y的乘法逆元。实现的 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/55761894&#34;&gt;python例子&lt;/a&gt;。&lt;/p&gt;
&lt;h5 id=&#34;2213-有限域中的椭圆曲线&#34;&gt;2.2.1.3 有限域中的椭圆曲线&lt;/h5&gt;
&lt;p&gt;两类椭圆曲线实质是有限域质数的选取不同，有限域质数的选取也决定了其域的规模。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;上图展示了如何在曲线 &lt;img src=&#34;https://www.zhihu.com/equation?tex=y%5E2+%5Cequiv+x%5E3+-+x+%2B+3+%5Cpmod%7B127%7D&#34; alt=&#34;[公式]&#34;&gt; 上计算点加法，其中 &lt;img src=&#34;https://www.zhihu.com/equation?tex=P+%3D+%2816%2C+20%29%2C+Q%3D%2841%2C120%29&#34; alt=&#34;[公式]&#34;&gt; 。注意连接点的线 &lt;img src=&#34;https://www.zhihu.com/equation?tex=y+%5Cequiv+4x+%2B+83+%5Cpmod%7B127%7D&#34; alt=&#34;[公式]&#34;&gt; 是如何在平面内“重复”出现的，&lt;strong&gt;这是$$F_p$$ 中的直线区别于实数域直线的一个重要特征&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在椭圆曲线中加入有限域的概念后，定义的点加法还需要满足以下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=Q+%2B+0+%3D+0+%2B+Q+%3D+Q&#34; alt=&#34;[公式]&#34;&gt; (根据单位元的定义).&lt;/li&gt;
&lt;li&gt;给定非零点 &lt;img src=&#34;https://www.zhihu.com/equation?tex=Q&#34; alt=&#34;[公式]&#34;&gt; ， &lt;img src=&#34;https://www.zhihu.com/equation?tex=Q&#34; alt=&#34;[公式]&#34;&gt; 的逆元是横坐标相同但纵坐标相反的点。或者说 &lt;img src=&#34;https://www.zhihu.com/equation?tex=-Q+%3D+%28x_Q%EF%BC%8C-y_Q+%5Cbmod%7Bp%7D%29&#34; alt=&#34;[公式]&#34;&gt; 。例如，如果 $$F_{29}$$中的曲线有一个点 &lt;img src=&#34;https://www.zhihu.com/equation?tex=Q+%3D+%282%EF%BC%8C5+%29&#34; alt=&#34;[公式]&#34;&gt; ，则逆元是 &lt;img src=&#34;https://www.zhihu.com/equation?tex=-Q+%3D+%282%EF%BC%8C-5+%5Cbmod%7B29%7D%29+%3D+%282%EF%BC%8C24+%29+&#34; alt=&#34;[公式]&#34;&gt; 。&lt;/li&gt;
&lt;li&gt;此外， &lt;img src=&#34;https://www.zhihu.com/equation?tex=P+%2B+%28-P%29+%3D+0&#34; alt=&#34;[公式]&#34;&gt; (根据逆元的定义)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2214-椭圆曲线群的阶和子群的阶&#34;&gt;2.2.1.4. 椭圆曲线群的阶和子群的阶&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;群组的阶&lt;/strong&gt;：可以表述为群组中所有元素的数量，记作p。&lt;/p&gt;
&lt;p&gt;一个群中的元素数量称为这个群的阶，即对应到椭圆曲线群的阶就是：在有限域上定义的椭圆曲线包含的点的数量。我们尝试把0到p-1的所有整数x代入方程，然后对于每个x都找到所有满足方程的解，这样我们就找到了曲线上所有的点。但是这样的算时间复杂度为 &lt;img src=&#34;https://www.zhihu.com/equation?tex=O%28p%29&#34; alt=&#34;[公式]&#34;&gt;，这样做不够高效，有一个更快的计算阶的算法:&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Schoof%27s_algorithm&#34;&gt;Schoof&amp;rsquo;s algorithm&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子群&lt;/strong&gt;：首先是一个群，并且它的所有元素是另一个群的非空子集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;循环子群&lt;/strong&gt;：是元素循环重复的子群，循环群中的每个元素都可以写成是一个基本元素的倍数（后面的子群都是循环子群）。&lt;/p&gt;
&lt;p&gt;椭圆曲线的点乘法有一个有趣的性质。取 &lt;img src=&#34;https://www.zhihu.com/equation?tex=y%5E2+%5Cequiv+x%5E3+%2B+2x+%2B+3+%5Cpmod%7B97%7D&#34; alt=&#34;[公式]&#34;&gt; 曲线上的点 &lt;img src=&#34;https://www.zhihu.com/equation?tex=P+%3D+%283%EF%BC%8C6+%29&#34; alt=&#34;[公式]&#34;&gt; 。现在我们计算出所有P的点乘倍数:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic4.zhimg.com/80/v2-99a7f7c31b6fdca1ab0f5e928a383a63_720w.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=0P+%3D+0&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=1P+%3D+%283%2C+6%29&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=2P+%3D+%2880%2C+10%29&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=3P+%3D+%2880%2C+87%29&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=4P+%3D+%283%2C+91%29&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=5P+%3D+0&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=6P+%3D+%283%2C+6%29&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=7P+%3D+%2880%2C+10%29&#34; alt=&#34;[公式]&#34;&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=%285k+%2B+1%29P+%3D+P&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=8P+%3D+%2880%2C+87%29&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=9P+%3D+%283%2C+91%29&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，我们可以立即发现：P的倍数只有5个点，椭圆曲线的其他点从未出现过。其次，它们是循环重复的。我们可以写作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=5kP+%3D+0&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=%285k+%2B+1%29P+%3D+P&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=%285k+%2B+2%29P+%3D+2P&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=%285k+%2B+3%29P+%3D+3P&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=%285k+%2B+4%29P+%3D+4P&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这五个方程可以被“压缩”成一个方程：&lt;img src=&#34;https://www.zhihu.com/equation?tex=kP+%3D+%28k+%5Cbmod%7B5%7D%29P&#34; alt=&#34;[公式]&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基点的选取&lt;/strong&gt;根据循环群中的每个元素都可以写成是一个基本元素的倍数，就像我们在前面的例子中展示的那样。我们把点P这样的基本元素称为循环子组的生成器或基点。&lt;/p&gt;
&lt;h5 id=&#34;2215-子群的阶&#34;&gt;2.2.1.5 子群的阶&lt;/h5&gt;
&lt;p&gt;由上述基点P所产生的子群的阶不能使用上文提到的Schoof算法来计算，因为该算法只适用于整个椭圆曲线，而不适用于子群。为了解决这个问题，引入定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们已经将阶定义为一个群的元素数量。这个定义仍然有效，但是在循环子组中，我们可以给出一个新的等价定义: **子群P的阶是使得 &lt;img src=&#34;https://www.zhihu.com/equation?tex=nP+%3D+0&#34; alt=&#34;[公式]&#34;&gt; 的最小的正整数 &lt;img src=&#34;https://www.zhihu.com/equation?tex=n&#34; alt=&#34;[公式]&#34;&gt; **。&lt;/li&gt;
&lt;li&gt;子群P的阶可以通过&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory)&#34;&gt;拉格朗日定理&lt;/a&gt;与椭圆曲线群的阶相联系，拉格朗日定理指出子群的阶是父群阶的除数。换句话说，如果椭圆曲线包含 &lt;img src=&#34;https://www.zhihu.com/equation?tex=N&#34; alt=&#34;[公式]&#34;&gt;个点，并且它的一个子群包含 &lt;img src=&#34;https://www.zhihu.com/equation?tex=n&#34; alt=&#34;[公式]&#34;&gt; 点，那么 &lt;img src=&#34;https://www.zhihu.com/equation?tex=n&#34; alt=&#34;[公式]&#34;&gt; 是的 &lt;img src=&#34;https://www.zhihu.com/equation?tex=N&#34; alt=&#34;[公式]&#34;&gt; 的除数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个信息组合在一起就给我们提供了一种找出一个基点为 &lt;img src=&#34;https://www.zhihu.com/equation?tex=P&#34; alt=&#34;[公式]&#34;&gt; 的子群的阶的思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用Schoof算法计算椭圆曲线群的阶数 &lt;img src=&#34;https://www.zhihu.com/equation?tex=N&#34; alt=&#34;[公式]&#34;&gt; ；&lt;/li&gt;
&lt;li&gt;找到 &lt;img src=&#34;https://www.zhihu.com/equation?tex=N&#34; alt=&#34;[公式]&#34;&gt; 的所有除数；&lt;/li&gt;
&lt;li&gt;对每个 &lt;img src=&#34;https://www.zhihu.com/equation?tex=N&#34; alt=&#34;[公式]&#34;&gt; 的除数 &lt;img src=&#34;https://www.zhihu.com/equation?tex=n&#34; alt=&#34;[公式]&#34;&gt; ，计算 &lt;img src=&#34;https://www.zhihu.com/equation?tex=nP&#34; alt=&#34;[公式]&#34;&gt; ；&lt;/li&gt;
&lt;li&gt;使 &lt;img src=&#34;https://www.zhihu.com/equation?tex=nP%3D0&#34; alt=&#34;[公式]&#34;&gt; 成立的最小 &lt;img src=&#34;https://www.zhihu.com/equation?tex=n&#34; alt=&#34;[公式]&#34;&gt; 就是子群P的阶。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当N是合数，它有很多整数，但是如果是一个素数，将只有1和本身。此时我们考虑一种特殊情况：假设一个椭圆曲线群的阶数 &lt;img src=&#34;https://www.zhihu.com/equation?tex=N&#34; alt=&#34;[公式]&#34;&gt; 是质数，那么这个椭圆曲线的子群的阶就只有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子群的阶是1，此时的子群只包含一个点0；&lt;/li&gt;
&lt;li&gt;子群的阶是N，此时的子群包含椭圆曲线上的所有点&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;2216-寻找一个基点&#34;&gt;2.2.1.6 寻找一个基点&lt;/h5&gt;
&lt;p&gt;对于我们的ECC算法，我们需要的是高阶的子群。所以一般来说，我们会选择一条椭圆曲线，计算它的阶数 &lt;img src=&#34;https://www.zhihu.com/equation?tex=N&#34; alt=&#34;[公式]&#34;&gt; ，选择一个较大的除数作为子群阶数 &lt;img src=&#34;https://www.zhihu.com/equation?tex=n&#34; alt=&#34;[公式]&#34;&gt; ，最终找到一个合适的基点。也就是说:我们不会选择一个基点然后计算它的阶，相反，**我们会首先选择一个看起来足够好的阶（也就是足够大），然后我们会寻找一个合适的基点。**下面详细讨论这一过程：&lt;/p&gt;
&lt;p&gt;有鉴于此，我们的算法概述如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算椭圆曲线的阶数 &lt;img src=&#34;https://www.zhihu.com/equation?tex=N&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;选择子群的阶数 &lt;img src=&#34;https://www.zhihu.com/equation?tex=n&#34; alt=&#34;[公式]&#34;&gt; 。为了使算法有效，这个数字必须是质数，并且必须是 &lt;img src=&#34;https://www.zhihu.com/equation?tex=N&#34; alt=&#34;[公式]&#34;&gt; 的除数。&lt;/li&gt;
&lt;li&gt;计算余因子&lt;img src=&#34;https://www.zhihu.com/equation?tex=h%3DN%2Fn&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;选择椭圆曲线上的一个随机点 &lt;img src=&#34;https://www.zhihu.com/equation?tex=P&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;计算 &lt;img src=&#34;https://www.zhihu.com/equation?tex=G%3DhP&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;li&gt;若 &lt;img src=&#34;https://www.zhihu.com/equation?tex=G%3D0&#34; alt=&#34;[公式]&#34;&gt; , 就回到步骤4， 否则，我们就找到了一个子群的基点，阶数为 &lt;img src=&#34;https://www.zhihu.com/equation?tex=n&#34; alt=&#34;[公式]&#34;&gt; 和余因子为 &lt;img src=&#34;https://www.zhihu.com/equation?tex=h&#34; alt=&#34;[公式]&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;请注意，此算法仅在 &lt;img src=&#34;https://www.zhihu.com/equation?tex=n&#34; alt=&#34;[公式]&#34;&gt; 是质数时有效。如果 &lt;img src=&#34;https://www.zhihu.com/equation?tex=n&#34; alt=&#34;[公式]&#34;&gt; 不是质数，那么 &lt;img src=&#34;https://www.zhihu.com/equation?tex=G&#34; alt=&#34;[公式]&#34;&gt; 的阶数可能是 &lt;img src=&#34;https://www.zhihu.com/equation?tex=n&#34; alt=&#34;[公式]&#34;&gt; 的除数之一。&lt;/p&gt;
&lt;h5 id=&#34;2217-椭圆曲线密码学&#34;&gt;2.2.1.7 椭圆曲线密码学&lt;/h5&gt;
&lt;p&gt;ECC算法流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 &lt;img src=&#34;https://www.zhihu.com/equation?tex=%5C%7B1%2C+%5Cdots%2C+n+-+1%5C%7D&#34; alt=&#34;[公式]&#34;&gt; 中随机选择一个整数 &lt;img src=&#34;https://www.zhihu.com/equation?tex=d&#34; alt=&#34;[公式]&#34;&gt; 作为私钥（ &lt;img src=&#34;https://www.zhihu.com/equation?tex=n&#34; alt=&#34;[公式]&#34;&gt; 是循环子群的阶数）&lt;/li&gt;
&lt;li&gt;计算公钥 &lt;img src=&#34;https://www.zhihu.com/equation?tex=H%3DdG&#34; alt=&#34;[公式]&#34;&gt; （ &lt;img src=&#34;https://www.zhihu.com/equation?tex=G&#34; alt=&#34;[公式]&#34;&gt; 是循环子群的基点）我们注意到，如果我们已知 &lt;img src=&#34;https://www.zhihu.com/equation?tex=d&#34; alt=&#34;[公式]&#34;&gt; （和椭圆曲线的领域参数），计算 &lt;img src=&#34;https://www.zhihu.com/equation?tex=H&#34; alt=&#34;[公式]&#34;&gt; （标量乘）是很容易的。但是在已知 &lt;img src=&#34;https://www.zhihu.com/equation?tex=H%3DdG&#34; alt=&#34;[公式]&#34;&gt; 的情况下，计算 &lt;img src=&#34;https://www.zhihu.com/equation?tex=d&#34; alt=&#34;[公式]&#34;&gt; 是“困难”的，因为这要求我们解一个离散对数问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ECDH（Elliptic curve Diffie-Hellman，一种加密算法）本质上是一个密钥协商协议，而不是一个加密算法。对于通讯双方定义了密钥生成和交换的规则，至于怎么用密钥对数据进行加密，取决于其他的算法。&lt;/p&gt;
&lt;p&gt;ECDSA（Elliptic Curve Digital Signature Algorithm，一种签名算法）：ESCDA处理的实际上是消息的哈希值，而不是消息本身。哈希函数是可选择的，但这个哈希函数必须是一个&lt;a href=&#34;https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Cryptographic_hash_function&#34;&gt;密码学安全的哈希函数&lt;/a&gt;。消息的哈希值需要截取一个固定的长度 &lt;img src=&#34;https://www.zhihu.com/equation?tex=L_n&#34; alt=&#34;[公式]&#34;&gt; ，这个长度是 &lt;img src=&#34;https://www.zhihu.com/equation?tex=n&#34; alt=&#34;[公式]&#34;&gt; （子群的阶）的二进制位数。截取后的哈希值是一个整数，我们记为 &lt;img src=&#34;https://www.zhihu.com/equation?tex=z&#34; alt=&#34;[公式]&#34;&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;222-椭圆曲线&#34;&gt;2.2.2 椭圆曲线&lt;/h4&gt;
&lt;p&gt;两类椭圆曲线实质是有限域质数的选取不同，有限域质数的选取也决定了其域的规模。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$$F_p$$ 上的椭圆曲线&lt;/p&gt;
&lt;p&gt;方程为：$$y^2 =x ^3 +ax+b$$，$$a,b \in F_p$$，且$$(4a^3 +27 b^2) mod \ p \neq 0$$&lt;/p&gt;
&lt;p&gt;椭圆曲线的定义为：$$E(F_p) = {(x,y)|x,y \in F_p, y^2 =x ^3 +ax+b} \cup {O}$$，O 是无穷远点&lt;/p&gt;
&lt;p&gt;椭圆曲线 $$E(F_p)$$ 上的点的数目称为椭圆曲线 $$E(F_p)$$ 的阶。（有限域的元素数量）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$$F_{2^m}$$ 上的椭圆曲线&lt;/p&gt;
&lt;p&gt;方程为：$$y^2 +xy =x ^3 +ax^2+b$$，$$a,b \in F_p$$，且$$b \neq 0$$&lt;/p&gt;
&lt;p&gt;椭圆曲线的定义为：$$E(F_{2^m}) = {(x,y)|x,y \in F_{2^m}, y^2 +xy =x ^3 +ax^2+b } \cup {O}$$，O 是无穷远点&lt;/p&gt;
&lt;p&gt;椭圆曲线 $$E(F_{2^m})$$ 上的点的数目称为椭圆曲线 $$E(F_{2^m})$$ 的阶&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;223-椭圆曲线参数&#34;&gt;2.2.3 椭圆曲线参数&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$$F_p$$ 上的椭圆曲线&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$$F_{2^m}$$ 上的椭圆曲线&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;确定一条椭圆曲线具体需要哪些参数分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数a, b 确定一条椭圆曲线的形状&lt;/li&gt;
&lt;li&gt;一个质数P用于描述有限域的大小&lt;/li&gt;
&lt;li&gt;一个用于生成循环子群的基点G&lt;/li&gt;
&lt;li&gt;子群（循环子群）的阶数n&lt;/li&gt;
&lt;li&gt;子群的协因子 &lt;img src=&#34;https://www.zhihu.com/equation?tex=h&#34; alt=&#34;[公式]&#34;&gt; （ &lt;img src=&#34;https://www.zhihu.com/equation?tex=h%3DN%2Fn&#34; alt=&#34;[公式]&#34;&gt; ，其中 &lt;img src=&#34;https://www.zhihu.com/equation?tex=N&#34; alt=&#34;[公式]&#34;&gt; 是椭圆曲线群的阶数）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这六个参数 &lt;img src=&#34;https://www.zhihu.com/equation?tex=%28p%2Ca%2Cb%2CG%2Cn%2Ch%29&#34; alt=&#34;[公式]&#34;&gt; 联合起来定义了一种ECC算法所用到的椭圆曲线。&lt;/p&gt;
&lt;p&gt;在代码上主要抓住两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;椭圆曲线群组中的点的运算。（加法和乘法）&lt;/li&gt;
&lt;li&gt;椭圆曲线有限域中横纵坐标的加减乘除运算。（除法采用扩展殴几里德算法）&lt;/li&gt;
&lt;li&gt;然后就是按照文档的步骤实现即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;23-密钥对生成和公钥验证算法&#34;&gt;2.3 密钥对生成和公钥验证算法&lt;/h3&gt;
&lt;h4 id=&#34;231-密钥对生成&#34;&gt;2.3.1 密钥对生成&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入：一个有效的 $$F_q$$ 上的椭圆曲线系统参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;a. 生成随机数 $$d \in [1,n-2]$$&lt;/p&gt;
&lt;p&gt;b. G 为基点，计算 $$P(x_p,y_p)$$ 点，$$P=G^d$$&lt;/p&gt;
&lt;p&gt;c. 生成密钥对是 $$(d,P)$$，其中 $$d$$ 是私钥，$$P$$ 是公钥&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出：密钥对 $$(d,P)$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;232-公钥验证&#34;&gt;2.3.2 公钥验证&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;输入：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	a. 一个有效的 $$F_q$$ 上的椭圆曲线系统参数&lt;/p&gt;
&lt;p&gt;​	b. 公钥 $$P(x_p,y_p)$$ 。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;步骤（验证公钥是否有效本质上就是在验证 P 点是否在椭圆曲线上）：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	a. 验证 P 点不是无穷远点&lt;/p&gt;
&lt;p&gt;​	b. 验证坐标 $$x_p$$ 和 $$y_p$$ 是否是区间 $$[0,p-1]$$ 内。&lt;/p&gt;
&lt;p&gt;​	c. 验证 $$y_p^2=x_p^3+ax_p+b(mod \ p)$$ 或 $$y_p^3+x_py_p = x_p^3+ax_p^3+b$$&lt;/p&gt;
&lt;p&gt;​	d. 验证 $$p^n=O$$&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;输出：若以上验证均成功，则输出”有效“，否则为无效&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;24-数字签名算法&#34;&gt;2.4 数字签名算法&lt;/h3&gt;
&lt;p&gt;数字签名算法由一个签名者对数据产生数字签名 ,并由一个验证者验证签名 的可靠性 。每个签名者有一个公钥和一个私钥 ,其 中私钥用于产生签名 ,验证者用签名者的公钥验证签名 。在签名的生成过程之前 ,要用密码杂凑函数对$$\overline{M}$$(包 含 $$Z_A$$ 和待签消息M)进行压缩 ;在 验证过程之前 ,要用密码杂凑函数对 $$\overline{M}$$ (包含 $$Z_A$$和待验证消息 M′ )进行压缩 。&lt;/p&gt;
&lt;h4 id=&#34;241-用户身份杂凑值&#34;&gt;2.4.1. 用户身份杂凑值&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;参数信息：&lt;/p&gt;
&lt;p&gt;假设用户 A 的身份标识为 $$ID_A$$，长度为 $$ENTL_A$$。&lt;/p&gt;
&lt;p&gt;椭圆曲线方程的参数为 a，b，基点 G 的坐标为 $$(X_G,Y_G)$$，用户 A 的公钥 $$P_A$$ 的坐标为 $$(X_A,Y_A)$$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;用户 A 的&lt;del&gt;杂凑值&lt;/del&gt; （Z值只是用来计算杂凑值的一个运算因子，并不是杂凑值）$$Z_A = H_{256}(ENTL_A || ID_A || a || b || x_G || y_G || x_A || y_A)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$$ENTL_A$$：为2个字节标识的ID的比特长度。&lt;/li&gt;
&lt;li&gt;$$ID_A$$：为用户身份标识。无特殊约定的情况下，用户身份标识ID的长度为16字节，其默认值从左到右依次为：&lt;code&gt;0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;$$a,b$$：为系统曲线参数。&lt;/li&gt;
&lt;li&gt;$$x_G, y_G$$：为基点；&lt;/li&gt;
&lt;li&gt;$$x_A,y_A$$：为用户的公钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;预处理2是指使用Z值和待签名消息，通过SM3运算得到杂凑值H的过程。杂凑值用于SM2数字签名。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：
&lt;ul&gt;
&lt;li&gt;$$Z_A$$：字节串，预处理2的输入。&lt;/li&gt;
&lt;li&gt;M：字节串，待签名消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;输出：
&lt;ul&gt;
&lt;li&gt;H：字节串，杂凑值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算公式：
&lt;ul&gt;
&lt;li&gt;$$H=SM3(Z_A||M)$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;242-签名算法&#34;&gt;2.4.2. 签名算法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;a. 待签名的消息 $$M$$&lt;/p&gt;
&lt;p&gt;b. 用户 A 信息的杂凑值 $$Z_A$$&lt;/p&gt;
&lt;p&gt;c. 用户 A 的私钥 $$d_A$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;a. 置 $$\overline{M} = Z_A || M$$&lt;/p&gt;
&lt;p&gt;b. 使用 SM3 计算杂凑值 $$e=H_v(\overline{M})$$ 等价于公式 $$H=SM3(Z_A||M)$$ 取前v个bit。&lt;/p&gt;
&lt;p&gt;c. 生成随机数 $$k \in [1,n-2]$$&lt;/p&gt;
&lt;p&gt;d. 计算椭圆曲线点 $$G^k=(x_1,y_1)$$&lt;/p&gt;
&lt;p&gt;e. 计算 $$r=(e+x_1)mod\ n$$，若 $$r=0$$ 或 $$r+k=n$$，返回步骤 c&lt;/p&gt;
&lt;p&gt;f. 计算 $$s = (\frac{k-r \cdot d_A}{1+d_A})mod \ n $$，若 $$s=0$$，返回步骤 c&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;签名消息为 $$(r,s)$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;243-验签算法&#34;&gt;2.4.3. 验签算法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;a. 待签名消息 $$M&#39;$$&lt;/p&gt;
&lt;p&gt;b. $$M&#39;$$ 的签名消息 $$(r&amp;rsquo;, s&amp;rsquo;)$$&lt;/p&gt;
&lt;p&gt;c. 用户 A 信息的杂凑值 $$Z_A$$&lt;/p&gt;
&lt;p&gt;d. 用户 A 的公钥 $$P_A $$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;a. 验证 $$r&amp;rsquo; \in [1, n-1]$$&lt;/p&gt;
&lt;p&gt;b. 验证 $$s&amp;rsquo; \in [1,n-1]$$&lt;/p&gt;
&lt;p&gt;c. 置 $$\overline{M&amp;rsquo;} = Z_A || M&#39;$$&lt;/p&gt;
&lt;p&gt;d. 使用 SM3 计算杂凑值 $$e=H_v(\overline{M&amp;rsquo;})$$&lt;/p&gt;
&lt;p&gt;e. 计算 $$t=(r&#39;+s&amp;rsquo;)mod \ n$$，验证 $$t != 0$$&lt;/p&gt;
&lt;p&gt;f. 计算 $$(x&amp;rsquo;,y&amp;rsquo;)=G^{s&amp;rsquo;}+P_A^{t}$$&lt;/p&gt;
&lt;p&gt;g. 计算 $$R=(e&#39;+x_1&amp;rsquo;)mod \ n$$，验证 $$R=r&#39;$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;化简：&lt;/p&gt;
&lt;p&gt;$$G^{s&amp;rsquo;}+P_A^{t} = G^{s&amp;rsquo;} + G^{(d_A \ mod \ n )\cdot t&amp;rsquo;} = G^{(s&#39;+d_A \cdot t&amp;rsquo;) mod \ n} = G^{(s&#39;+d_A \cdot (r&#39;+s&amp;rsquo;)) mod \ n}$$&lt;/p&gt;
&lt;p&gt;$$= G^{(s&amp;rsquo;(1+d_A) + d_A \cdot r&amp;rsquo;)mod \ n} = G^{(\frac{k-r&amp;rsquo; \cdot d_A}{1+d_A}(1+d_A) +d_A \cdot r&amp;rsquo;) mod \ n} $$&lt;/p&gt;
&lt;p&gt;$$= G^{(k-r&amp;rsquo; \cdot d_A + r&amp;rsquo; \cdot d_A) mod \ n} = G^k$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;若步骤 a，b，e，g 都验证通过，则输出验证成功，否则输出验证失败&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;244-数字签名算法实现&#34;&gt;2.4.4. 数字签名算法实现&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/citahub/libsm/blob/master/docs/images/sm2.png?raw=true&#34; alt=&#34;sm2.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;25-密钥交换算法&#34;&gt;2.5 密钥交换算法&lt;/h3&gt;
&lt;p&gt;密钥交换是指在用户 A，B 之间进行密钥交换协商的过程。用各自的私钥和对方的公钥来商定一只只有他们知道的秘密密钥。这个共享的秘密密钥通常用在某个对称密码学算法中，该密钥交换协议能够用于密钥管理和协商。&lt;/p&gt;
&lt;h4 id=&#34;251-密钥交换算法&#34;&gt;2.5.1 密钥交换算法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;相关参数&lt;/p&gt;
&lt;p&gt;a. 用户 A 的私钥 $$d_A$$，公钥 $$P_A $$&lt;/p&gt;
&lt;p&gt;b. 用户 B 的私钥 $$d_B$$，公钥 $$P_B$$&lt;/p&gt;
&lt;p&gt;c. 用户 A 的杂凑值 $$Z_A = H_{256}(ENTL_A || ID_A || a || b || x_G || y_G || x_A || y_A)$$&lt;/p&gt;
&lt;p&gt;d. 用户 B 的杂凑值 $$Z_B = H_{256}(ENTL_B || ID_B || a || b || x_G || y_G || x_B || y_B)$$&lt;/p&gt;
&lt;p&gt;e. $$w= \lceil (\lceil log_2(n) \rceil /2) \rceil - 1$$&lt;/p&gt;
&lt;p&gt;f. $$h$$ 为 $$n$$ 的余因子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;用户 A&lt;/strong&gt;：产生随机数 $$r_A \in [1,n-1]$$，并计算 $$R_A = G^{r_A} = (x_1,y_1)$$，将 $$R_A$$ 发送给 B。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户 A&lt;/strong&gt;：计算 $$\overline{x_1} = 2^w +(x_1 \ &amp;amp; \ (2^w-1))$$，代入计算 $$t_A = (d_A + \overline{x_1} \cdot r_A) mod \ n $$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户 B&lt;/strong&gt;：产生随机数 $$r_B \in [1,n-1]$$，并计算 $$R_B = G^{r_B} = (x_2,y_2)$$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户 B&lt;/strong&gt;：计算 $$\overline{x_2} = 2^w +(x_2 \ &amp;amp; \ (2^w-1))$$，代入计算 $$t_B = (d_B + \overline{x_2} \cdot r_B) mod \ n $$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户 B&lt;/strong&gt;：验证 $$R_A$$ 是否满足曲线的方程，如果不满足，则协商失败，终止（参考 2.3.2 公钥验证）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户 B&lt;/strong&gt;：计算 $$\overline{x_1} = 2^w +(x_1 \ &amp;amp; \ (2^w-1))$$，代入计算 $$V = (P_A+R_A^{\overline{x_1}})^{h \cdot t_B} = (x_V,y_V)$$，验证 $$V \ ?=0$$，如果是，则协商失败，终止。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户 B&lt;/strong&gt;：计算 $$K_B = KDF(x_V||y_V||Z_A||Z_B,klen)$$，代入计算哈希值 $$S_B = Hash(0x02 ||y_V ||Hash(x_V || Z_A || Z_B || x_1 ||y_1||x_2||y_2))$$，将 $$R_B$$ 和 $$S_B$$ 发送给用户 A&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户 A&lt;/strong&gt;：验证 $$R_B$$ 是否满足曲线的方程，如果不满足，则协商失败，终止（参考 2.3.2 公钥验证）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户 A&lt;/strong&gt;：计算 $$\overline{x_2} = 2^w +(x_2 \ &amp;amp; \ (2^w-1))$$，代入计算 $$U = (P_B + R_B^{\overline{x_2}})^{h \cdot t_A} = (x_U,y_U)$$，验证 $$U \ ?=0$$，如果是，则协商失败，终止。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户 A&lt;/strong&gt;：计算 $$K_A= KDF(x_U||y_U||Z_A||Z_B,klen)$$，代入计算哈希值  $$S_1 = Hash(0x02 ||y_U||Hash(x_U || Z_A || Z_B || x_1 ||y_1||x_2||y_2))$$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户 A&lt;/strong&gt;：验证 $$S_1 \ ?= S_B$$，若不一致，则协商失败，终止。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户 A&lt;/strong&gt;：计算 $$S_A = Hash(0x03 ||y_V||Hash(x_V|| Z_A || Z_B || x_1 ||y_1||x_2||y_2))$$ ，并将 $$S_A$$ 发送给用户 B。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户 B&lt;/strong&gt;：计算 $$S_2 = Hash(0x03 ||y_U||Hash(x_U|| Z_A || Z_B || x_1 ||y_1||x_2||y_2))$$ ，验证 $$S_2 \ ?= S_A$$，若不一致，则协商失败，终止。&lt;/li&gt;
&lt;li&gt;协商成功，$$K_A$$，$$K_B$$ 即为协商的密钥，而后续的 $$S_1$$，$$S_2$$，$$S_A$$，$$S_B$$ 验证则为可选项。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;推导 $$K_A = K_B$$：&lt;/p&gt;
&lt;p&gt;$$V = (P_A+R_A^{\overline{x_1}})^{h \cdot t_B}  = (G^{d_A} +(G^{r_A})^{\overline{x_2}})^{h \cdot t_B} = (G^{d_A + \overline{x_2} \cdot r_A })^{h \cdot t_B} = (x_V,y_V)$$&lt;/p&gt;
&lt;p&gt;$$U = (P_B + R_B^{\overline{x_2}})^{h \cdot t_A} = (G^{d_B}+(G^{r_B})^{\overline{x_2}})^{h \cdot t_A} = (G^{d_B+\overline{x_2} \cdot r_B})^{h \cdot t_A} = G^{h \cdot t_A \cdot t_B} = (x_U,y_U)$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;252-密钥交换算法实现&#34;&gt;2.5.2 密钥交换算法实现&lt;/h4&gt;
&lt;h3 id=&#34;26-非对称加解密算法&#34;&gt;2.6 非对称加解密算法&lt;/h3&gt;
&lt;h4 id=&#34;261-密钥派生算法kdf&#34;&gt;2.6.1 密钥派生算法（KDF）&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;杂凑函数&lt;/p&gt;
&lt;p&gt;a. 密码杂凑函数 $$H_v()$$，其中 v 是杂凑值的长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;a. 比特串 Z&lt;/p&gt;
&lt;p&gt;b. 派生出来的密钥长度 $$klen$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;a. 设置计数器 ct=1&lt;/p&gt;
&lt;p&gt;b. for $$i=1; k&amp;lt;\lceil klen/v \rceil; i++$${&lt;/p&gt;
&lt;p&gt;​		$$H_{a_i} = H_v(Z || ct)$$&lt;/p&gt;
&lt;p&gt;​		$$ct++$$&lt;/p&gt;
&lt;p&gt;​	}&lt;/p&gt;
&lt;p&gt;c. 若 $$klen/v$$ 为整数，令 $$Ha!&lt;em&gt;{\lceil klen/v \rceil} =Ha&lt;/em&gt;{\lceil klen/v \rceil}$$;&lt;/p&gt;
&lt;p&gt;​	否则，$$Ha!&lt;em&gt;{\lceil klen/v \rceil}  = Ha&lt;/em&gt;{\lceil klen/v \rceil}[0,klen-(v \times \lfloor klen/v \rfloor)-1] $$&lt;/p&gt;
&lt;p&gt;d. 令 $$K=Ha_1 || Ha_2 || … || Ha_{\lceil klen/v \rceil -1} || Ha!_{\lceil klen/v \rceil }$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;密钥 $$K$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;262-加密算法&#34;&gt;2.6.2 加密算法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;a. 待加密的信息 $$M$$，长度为 $$klen$$&lt;/p&gt;
&lt;p&gt;b. 用户 B 的公钥 $$P_B$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;a. 生成随机数 $$k \in [1,n-1]$$&lt;/p&gt;
&lt;p&gt;b. 计算 $$C_1 = G^k =(x_1,y_1)$$&lt;/p&gt;
&lt;p&gt;c. 计算 $$S=P_B^h$$，若 $$S=O$$，则报错（h 为 n 的余因子）&lt;/p&gt;
&lt;p&gt;d. 计算 $$P_B^k=(x_2,y_2)$$&lt;/p&gt;
&lt;p&gt;e. 派生密钥 $$t=KDF(x_2||y_2,klen)$$，若 t 为全 0 的比特串，返回步骤 a&lt;/p&gt;
&lt;p&gt;f.  计算 $$C_2= M \oplus t$$&lt;/p&gt;
&lt;p&gt;g. 计算哈希值 $$C_3 =Hash(x_2 || M || y_2)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;密文 $$C = C_1 || C_3 || C_2$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;263-解密算法&#34;&gt;2.6.3 解密算法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;a. 密文 $$C = C_1 || C_2 || C_3$$&lt;/p&gt;
&lt;p&gt;b. 用户 b 的私钥 $$d_A$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;a. 验证 $$C_1$$ 是否满足曲线方程&lt;/p&gt;
&lt;p&gt;b. 计算 $$S = C_1^h$$，若 $$S=O$$，则报错&lt;/p&gt;
&lt;p&gt;c. 计算 $$C_1^{d_B} = (x_2,y_2)$$&lt;/p&gt;
&lt;p&gt;d. 计算 $$t = KDF(x_2||y_2,klen)$$，若 t 为全 0 的比特串，则报错&lt;/p&gt;
&lt;p&gt;e. 计算 $$M&#39;= C_2 \oplus t $$&lt;/p&gt;
&lt;p&gt;f. 计算 $$u = Hash(x_2||M&#39;||y_2)$$，验证 $$u = C_3$$，若验证失败则报错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;明文 $$M&#39;$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;264-加解密算法实现&#34;&gt;2.6.4 加解密算法实现&lt;/h3&gt;
&lt;h2 id=&#34;3sm3&#34;&gt;3.SM3&lt;/h2&gt;
&lt;h3 id=&#34;31-简介&#34;&gt;3.1 简介&lt;/h3&gt;
&lt;p&gt;SM3 为密码哈希算法，用于替代 MD5/SHA-1/SHA-256 等国际算法。&lt;/p&gt;
&lt;h3 id=&#34;32-密码杂凑算法&#34;&gt;3.2 密码杂凑算法&lt;/h3&gt;
&lt;p&gt;密码杂凑算法的输入值 $$m$$，是长度为 l 的比特消息（$$l &amp;lt; 2^{64}$$）。&lt;/p&gt;
&lt;h4 id=&#34;321-填充&#34;&gt;3.2.1 填充&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;消息 $$m$$ 后填充一位 1&lt;/li&gt;
&lt;li&gt;再填充 $$k$$ 位的 0，使得 $$(l+1+k)mod \ 512 =448$$&lt;/li&gt;
&lt;li&gt;再添加 64 位比特串，内容为 $$l$$ 的二进制表示&lt;/li&gt;
&lt;li&gt;填充后的完整消息为 $$m’$$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;![image-20200219222124881](/Users/evenlu/Library/Application Support/typora-user-images/image-20200219222124881.png)&lt;/p&gt;
&lt;h4 id=&#34;322-迭代压缩&#34;&gt;3.2.2 迭代压缩&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;迭代处理&lt;/p&gt;
&lt;p&gt;a. 将 $$m&#39;$$ 以512位为单位进行分组，$$m&#39;=B_0||B_1||……||B_{n-1}$$，其中 $$n = (l+k+65)/512$$&lt;/p&gt;
&lt;p&gt;b. 从 0 到 n-1 逐个进行迭代：$$V_{i+1} = CF(V_i,B_i)$$，其中 $$CF()$$ 为压缩函数，$$V_0$$ 是一个初始值 IV，为一个固定值&lt;/p&gt;
&lt;p&gt;$$V_n$$ 就是杂凑值&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;323-压缩函数cf&#34;&gt;3.2.3 压缩函数CF()&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;消息扩展&lt;/p&gt;
&lt;p&gt;a. 将 $$B_i$$ 划分成16份，$$B_i = W_0 || W_1 || W_2 || … || W_{15}$$&lt;/p&gt;
&lt;p&gt;b. for j=16; j&amp;lt;=67; j++ {&lt;/p&gt;
&lt;p&gt;​		$$W_j = P_1(W_{j-16}) \oplus W_{j-9} \oplus (W_{j-3} &amp;laquo;&amp;lt;15) \oplus (W_{j-1} &amp;laquo;&amp;lt; 7) \oplus W_{j-6} $$&lt;/p&gt;
&lt;p&gt;​	}&lt;/p&gt;
&lt;p&gt;c. for j=0 ;j++; j&amp;lt;=63{&lt;/p&gt;
&lt;p&gt;​		$$W&amp;rsquo;&lt;em&gt;j=W_j \oplus W&lt;/em&gt;{j+4}$$&lt;/p&gt;
&lt;p&gt;​	}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;压缩函数&lt;/p&gt;
&lt;p&gt;a. 令 $$V_i = ABCDEF$$&lt;/p&gt;
&lt;p&gt;b. for j=0;j&amp;lt;64;j++{&lt;/p&gt;
&lt;p&gt;​		$$SS1 = (A&amp;laquo;&amp;lt;12)+E+(T_j &amp;laquo;&amp;lt;(j \ mod \ 32))&amp;laquo;&amp;lt; 7$$&lt;/p&gt;
&lt;p&gt;​		$$SS2 = SS1 \oplus  (A &amp;laquo;&amp;lt; 12)$$&lt;/p&gt;
&lt;p&gt;​		$$TT1 = FF_j(A,B,C) +D + SS2 + W_j&#39;$$&lt;/p&gt;
&lt;p&gt;​		$$TT2 = GG_j(E,F,G)+H+SS1+W_j$$&lt;/p&gt;
&lt;p&gt;​		$$D = C$$&lt;/p&gt;
&lt;p&gt;​		$$C = B &amp;laquo;&amp;lt; 9$$&lt;/p&gt;
&lt;p&gt;​		$$B = A$$&lt;/p&gt;
&lt;p&gt;​		$$A = TT1$$&lt;/p&gt;
&lt;p&gt;​		$$H = G$$&lt;/p&gt;
&lt;p&gt;​		$$G = F &amp;laquo;&amp;lt;19$$&lt;/p&gt;
&lt;p&gt;​		$$F = E$$&lt;/p&gt;
&lt;p&gt;​		$$E = P_0(TT2)$$&lt;/p&gt;
&lt;p&gt;​	}&lt;/p&gt;
&lt;p&gt;c. 计算 $$V_{i+1} = ABCDEFGH \oplus V_i $$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4sm4&#34;&gt;4.SM4&lt;/h2&gt;
&lt;h3 id=&#34;41-简介&#34;&gt;4.1 简介&lt;/h3&gt;
&lt;p&gt;SM4 为分组密码，用于替代 DES/AES 等国际算法。&lt;/p&gt;
&lt;p&gt;SM4 密码算法是一个分组算法，该算法的分组长度为 128 比特，密钥长度为 128 比特。加密算法和密钥扩展算法都采用 32 轮非线性迭代。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分组加密&lt;/strong&gt;（英语：&lt;strong&gt;Block cipher&lt;/strong&gt;），又称&lt;strong&gt;分块加密&lt;/strong&gt;或&lt;strong&gt;块密码&lt;/strong&gt;，是一种&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E7%AE%97%E6%B3%95&#34;&gt;对称密钥算法&lt;/a&gt;。它将明文分成多个等长的模块（block），使用确定的算法和&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5&#34;&gt;对称密钥&lt;/a&gt;对每组分别加密解密。&lt;/p&gt;
&lt;h3 id=&#34;42-分组加密算法&#34;&gt;4.2 分组加密算法&lt;/h3&gt;
&lt;p&gt;对于每一个分组长度为 128 比特的明文分组，进行加密。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;加密密钥：$$MK=(MK_0,MK_1,MK_2,MK_3)$$，其中$$MK_i$$ 为 32 比特，$$MK$$ 总共为 128 比1特。&lt;/p&gt;
&lt;p&gt;轮密钥：$$(rk_0,rk_1,…,rk_{31})$$&lt;/p&gt;
&lt;p&gt;明文：$$(X_0,X_1,X_2,X_3)$$，其中$$X_i$$ 为 32 比特，$$X$$ 总共为 128 比特。&lt;/p&gt;
&lt;p&gt;密文：$$(Y_0,Y_1,Y_2,Y_3)$$，其中$$Y_i$$ 为 32 比特，$$Y$$ 总共为 128 比特。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;明文：$$(X_0,X_1,X_2,X_3)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;a. for i=0; i&amp;lt;32;i++{&lt;/p&gt;
&lt;p&gt;​		$$X_{i+4} = F(X_i,X_{i+1},X_{i+2},X_{i+3},rk_i)= X_i \oplus T(X_{i+1} \oplus X_{i+2} \oplus X_{i+3} \oplus rk_i)$$&lt;/p&gt;
&lt;p&gt;​	}&lt;/p&gt;
&lt;p&gt;​	其中 $$T()$$ 为转置函数，$$T(A) = L(τ(A))$$，&lt;/p&gt;
&lt;p&gt;​	假设$$A= (a_0,a_1,a_2,a_3)$$， $$τ(A) = (Sbox(a_0),Sbox(a_1),Sbox(a_2),Sbox(a_3))$$&lt;/p&gt;
&lt;p&gt;$$L(A) = A \oplus (A &amp;laquo;&amp;lt; 2) \oplus (B &amp;laquo;&amp;lt; 10) \oplus (B &amp;laquo;&amp;lt; 18) \oplus (B &amp;laquo;&amp;lt; 24)$$&lt;/p&gt;
&lt;p&gt;b. 反序求得： $$(Y_0,Y_1,Y_2,Y_3) = (X_35,X_34,X_33,X_32)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;密文：$$(Y_0,Y_1,Y_2,Y_3)$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-分组解密算法&#34;&gt;4.3 分组解密算法&lt;/h3&gt;
&lt;p&gt;分组解密算法和加密算法相同，区别只有 32 轮迭代时，轮密钥 $$rk_i$$ 的使用顺序需要颠倒。&lt;/p&gt;
&lt;h4 id=&#34;431-密钥扩展算法&#34;&gt;4.3.1 密钥扩展算法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;加密密钥：$$MK=(MK_0,MK_1,MK_2,MK_3)$$，其中$$MK_i$$ 为 32 比特，$$MK$$ 总共为 128 比1特。&lt;/p&gt;
&lt;p&gt;$$FK = (FK_0,FK_1,FK_2,FK_3)$$ 为固定的系统参数，$$FK_0 = (A3B1BAC6)，FK_1 = (56AA3350)，FK_2 = (677D9197)，FK_3=(B27022DC)$$&lt;/p&gt;
&lt;p&gt;$$CK = (CK_0,CK_1,……,CK_{31})$$ 为固定参数，$$CK_i = (ck_{i,0},ck_{i,1},ck_{i,2},ck_{i,3})$$，$$ck_{i,j} = (4i+j) \times 7(mod \ 256)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;$$(K_0, K_1, K_2, K_3) = (MK_0 \oplus FK_0, MK_1 \oplus FK_1, MK_2 \oplus FK_2, MK_3 \oplus FK_3)$$&lt;/p&gt;
&lt;p&gt;$$rk_i = K_{i+4} = K_i \oplus T&amp;rsquo;(K_{i+1} \oplus K_{i+2} \oplus K_{i+3} \oplus CK_i)$$&lt;/p&gt;
&lt;p&gt;$$T&amp;rsquo;(A) = L&amp;rsquo;(τ(A))$$&lt;/p&gt;
&lt;p&gt;$$L&amp;rsquo;(A) = A \oplus (A &amp;laquo;&amp;lt; 13) \oplus (A &amp;laquo;&amp;lt; 23)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;$${rk_i}$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5sm9&#34;&gt;5.SM9&lt;/h2&gt;
&lt;h3 id=&#34;51-简介&#34;&gt;5.1 简介&lt;/h3&gt;
&lt;p&gt;SM9 为基于身份的密码算法，可以替代基于数字证书的 PKI/CA 体系。通过部署国密算法，可以降低由弱密码和错误实现带来的安全风险和部署 PKI/CA 带来的开销。&lt;/p&gt;
&lt;h3 id=&#34;52-数据类型及其转换&#34;&gt;5.2 数据类型及其转换&lt;/h3&gt;
&lt;p&gt;在本部分中，数据类型包括比特串，字节串，域运算，椭圆曲线上的点和整数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;521-数据类型转换之间的关系&#34;&gt;5.2.1 数据类型转换之间的关系&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;522-密码学杂凑函数&#34;&gt;5.2.2 密码学杂凑函数&lt;/h4&gt;
&lt;h5 id=&#34;5221-密码杂凑函数h_v&#34;&gt;5.2.2.1 密码杂凑函数$$H_v()$$&lt;/h5&gt;
&lt;p&gt;密码杂凑函数$$H_v()$$的输入是长度恰为v比特的杂凑值。本部分规定使用国家密码管理主管部门批准的密码杂凑函数，如SM3密码杂凑算法。&lt;/p&gt;
&lt;h5 id=&#34;5222-密码函数h_1&#34;&gt;5.2.2.2 密码函数$$H_1()$$&lt;/h5&gt;
&lt;p&gt;密码函数$$H_1(Z,n)$$的输入比比特串Z和整数n，输出为一个整数$$h_1\in[1,n-1]$$。$$H_1(Z,n)$$需要调用密码杂凑函数$$H_v()$$。&lt;/p&gt;
&lt;p&gt;密码函数$$H_1(Z,n)$$:&lt;/p&gt;
&lt;p&gt;输入：比特串Z，整数n&lt;/p&gt;
&lt;p&gt;输出：整数$$h_1 \in [1,n-1]$$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始化一个32比特构成的计数器ct=0x00000001;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算$$hlen=8*\lceil 5*(log_2n)/32 \rceil$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对i从1到$$\lceil hlen/v \rceil$$执行：&lt;/p&gt;
&lt;p&gt;3.1 计算$$H_{a_i}=H_v(0x01||Z || ct)$$&lt;/p&gt;
&lt;p&gt;3.2 ct++&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若$$hlen/v$$是整数，令$$Ha!\lceil hlen/v \rceil = Ha \lceil hlen/v\rceil$$，&lt;/p&gt;
&lt;p&gt;否则令$$Ha！_{\lceil hlen/v\rceil}$$为 $$Ha \lceil hlen/v\rceil$$最左边的$$(hlen-(v*\lfloor hlen/v \rfloor))$$比特&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;令$$Ha=Ha_1 || Ha_2 || &amp;hellip;. || Ha_a{\lceil hlen/v \rceil -1 } || Ha!_{\lceil hlen/v \rceil}$$ 按照2.4和2.3的步骤将$$Ha$$ 比特串转换为整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算$$h_2 = ({Ha} mod (n-1))+1$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5223-密码函数h_2&#34;&gt;5.2.2.3 密码函数$$H_2()$$&lt;/h5&gt;
&lt;p&gt;密码函数$$H_2(Z,n)$$的输入比比特串Z和整数n，输出为一个整数$$h_2\in[1,n-1]$$。$$H_2(Z,n)$$需要调用密码杂凑函数$$H_v()$$。&lt;/p&gt;
&lt;p&gt;密码函数$$H_2(Z,n)$$:&lt;/p&gt;
&lt;p&gt;输入：比特串Z，整数n&lt;/p&gt;
&lt;p&gt;输出：整数$$h_2 \in [1,n-1]$$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始化一个32比特构成的计数器ct=0x00000001;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算$$hlen=8*\lceil 5*(log_2n)/32 \rceil$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对i从1到$$\lceil hlen/v \rceil$$执行：&lt;/p&gt;
&lt;p&gt;3.1 计算$$H_{a_i}=H_v(0x02||Z || ct)$$&lt;/p&gt;
&lt;p&gt;3.2 ct++&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若$$hlen/v$$是整数，令$$Ha!\lceil hlen/v \rceil = Ha \lceil hlen/v\rceil$$，&lt;/p&gt;
&lt;p&gt;否则令$$Ha！_{\lceil hlen/v\rceil}$$为 $$Ha \lceil hlen/v\rceil$$最左边的$$(hlen-(v*\lfloor hlen/v \rfloor))$$比特&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;令$$Ha=Ha_1 || Ha_2 || &amp;hellip;. || Ha_a{\lceil hlen/v \rceil -1} || Ha!_{\lceil hlen/v \rceil}$$ 按照2.4和2.3的步骤将$$Ha$$ 比特串转换为整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算$$h_2 = ({Ha} mod (n-1))+1$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;53-基于标识的数字签名算法&#34;&gt;5.3 基于标识的数字签名算法&lt;/h3&gt;
&lt;p&gt;本部分描述了用椭圆曲线对实现的基于标识的数字签名算法。本部分适用于接收者通过签名者的标识验证数据的完整性和数据发送者的身份，也适用于第三方确定签名及所签数据的真实性。&lt;/p&gt;
&lt;p&gt;该算法的签名者持有一个标识和一个相应的签名私钥，该签名私钥由密钥生成中心通过签名主私钥和签名者的标识结合产生。签名者用自身签名私钥对数据产生数字签名，验证者用签名者的标识验证签名的可靠性。&lt;/p&gt;
&lt;h4 id=&#34;531-数字签名生成算法流程&#34;&gt;5.3.1 数字签名生成算法流程&lt;/h4&gt;
&lt;p&gt;设待签名的消息为比特串M，为了获取消息M的数字签名（h,S）,作为签名者的用户A实现以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算群$$G_T$$ 中的元素$$g=e(p_1,P_{pub-s})$$&lt;/li&gt;
&lt;li&gt;产生随机数$$r\in[1,N-1]$$&lt;/li&gt;
&lt;li&gt;计算群$$G_T$$ 中的元素$$w=g^r$$，并且按照上述的6.2.6 和6.2.5的细节将域元素转换为字节串然后转换为比特串。&lt;/li&gt;
&lt;li&gt;计算整数$$h=H_2(M||w,N)$$&lt;/li&gt;
&lt;li&gt;计算整数$$l=(r-h)modN$$，若$$l=0$$ 则返回A2&lt;/li&gt;
&lt;li&gt;计算群G1中的元素S=$$d_{s_A}^l$$&lt;/li&gt;
&lt;li&gt;按照上述数据转换流程将整数h的数据类型转换为字节串。将点S的数据类型转换为字节串，消息M的签名为$$(h,S)$$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据签名生成算法流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;53-数字签名验证算法&#34;&gt;5.3 数字签名验证算法&lt;/h3&gt;
&lt;p&gt;为了检验收到的消息M及其数字签名(h,S)，作为验证者的用户B应实现以下运算步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按照6.2.3的步骤将字符串转换为整数类型，检验$$h \in [1,N-1]$$是否成立，若不成立则验证不通过。&lt;/li&gt;
&lt;li&gt;按照6.2.9步骤将字符串S的数据类型转换为椭圆曲线上的点，然后检验$$S\in G_1$$是否成立，若不成立则验证不通过&lt;/li&gt;
&lt;li&gt;计算群$$G_T$$ 中的元素$$g=e(P_1,P_{pub-s})$$&lt;/li&gt;
&lt;li&gt;计算群$$G_T$$中的元素$$t=g^h$$&lt;/li&gt;
&lt;li&gt;计算整数$$h_1=H_1(ID_A||hid,N)$$&lt;/li&gt;
&lt;li&gt;计算群$$G_2$$中的元素$$P=P_2^{h_1}+P_{pub-s}$$&lt;/li&gt;
&lt;li&gt;计算群$$G_T$$中的元素$$u=e(S,P)$$&lt;/li&gt;
&lt;li&gt;计算群$$G_T$$中的元素$$w=u*t$$，将域元素W按照6.2.6和6.2.5的步骤转换为数据类型比特串。&lt;/li&gt;
&lt;li&gt;计算整数$$h_2=H_2(M||w,N)$$，检验h2=h是否成立，若成立则验证通过，否则验证不通过。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数字签名算法流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;54-密钥封装和公钥加密&#34;&gt;5.4 密钥封装和公钥加密&lt;/h3&gt;
&lt;p&gt;本部分规定了用椭圆曲线对实现的基于标识的密钥封装机制和公钥加密与解密算法。利用密钥封装机制可以封装密钥给特定实体。公钥加密与解密算法即基于标识的非对称密码算法，该算法使消息发送者可以利用接收者的标识对消息进行加密，唯有接收者可以用相应的私钥对密文进行解密，从未获取消息。&lt;/p&gt;
&lt;h4 id=&#34;541-密钥封装算法&#34;&gt;5.4.1 密钥封装算法&lt;/h4&gt;
&lt;p&gt;为了封装比特长度为klen的密钥给用户B，作为封装者的用户A需要执行以下运算步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算群G1中的元素$$Q_B=P_1^{[H_1(ID_B || hid,N)]} + p_{pub-e}$$&lt;/li&gt;
&lt;li&gt;产生随机数$r\in[1,N-1]$&lt;/li&gt;
&lt;li&gt;计算群G1中的元素$C=[r]Q_B$，按照2.8和2.5将点转化为字符串然后转化为比特串&lt;/li&gt;
&lt;li&gt;计算群$G_T$中的元素$g=e(P_{pub-e},P_2)$&lt;/li&gt;
&lt;li&gt;计算群$G_T$中的元素$w=g^r$，按照2.6和2.5的细节将w数据由域元素转化为字符串，然后转化为比特串。&lt;/li&gt;
&lt;li&gt;计算$K=KDF(C||w||ID_B,klen)$，若K为全0比特串，则返回步骤2&lt;/li&gt;
&lt;li&gt;输出(K,C)，其中K是被封装的密钥，C是封装密文。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;10.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;542-解封装算法&#34;&gt;5.4.2 解封装算法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先按照4.5给出的细节验证$C \in G_1$是否成立，若不成立则报错退出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算群$G_T$中的元素$w=e(C,de_B)$，按照2.6和2.5给出的细节将w域元素转化为字符串再转化为比特串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照2.6和2.5将C的数据类型由域元素转化为字符串再转化为比特串，计算封装的密钥$K=KDF(C||w||ID_B,klen)$，若K为全0比特串，则报错并且退出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出密钥K&lt;/p&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;11.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;55-sm9_free的代码结构&#34;&gt;5.5 SM9_FREE的代码结构&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;SM9_FREE
├── Makefile
├── SM9Test.c
├── SM9文档 //SM9的文档，写的比官方文档要好懂一点
├── miracl //大数运算的基础库，为椭圆曲线有限域的运算提供基础
└── sm9
    ├── print_out.c // 格式化打印
    ├── print_out.h
    ├── sm3.c       //SM3杂凑哈希
    ├── sm3.h       
    ├── sm4.c       //SM4对称加解密
    ├── sm4.h
    ├── sm9_algorithm.h  
    ├── sm9_encrypt.c  // SM9加解密
    ├── sm9_keyexchange.c //SM9密钥交换
    ├── sm9_setup.c
    ├── sm9_signature.c    //SM9签名和验签
    ├── sm9_utils.c        //SM9的工具函数，比如H1和H2的杂凑函数
    ├── sm9_utils.h
    ├── sm_r-ate.c         // R-ate双线性对的运算
    ├── smzzn12.c          // 为R-ate双线性对提供底层的双线性对计算
    └── smzzn12.h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;6总结&#34;&gt;6.总结&lt;/h2&gt;
&lt;p&gt;SM9实现起来不是很容易，对于SM9_FREE的代码实现主要存在以下三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码实现中的参数名称和文档中的参数名称对不上，导致代码理解起来不容易。&lt;/li&gt;
&lt;li&gt;代码接口比较原始，使用起来不方便和文档流程对应不上。&lt;/li&gt;
&lt;li&gt;对底层的&lt;code&gt;miracl &lt;/code&gt;大数运算的用法，以及r-ate的实现不清楚。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;http://gmssl.org/&#34;&gt;http://gmssl.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&#34;https://zhuanlan.zhihu.com/p/55758642&#34;&gt;https://zhuanlan.zhihu.com/p/55758642&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SM9的参考文档&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[2]  &lt;a href=&#34;https://github.com/songgeng87/SM9_FREE/tree/master/SM9_FREE/SM9%E6%96%87%E6%A1%A3&#34;&gt;https://github.com/songgeng87/SM9_FREE/tree/master/SM9_FREE/SM9%E6%96%87%E6%A1%A3&lt;/a&gt;   (SM9实现的文档)&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&#34;https://github.com/guanzhi/GM-Standards/tree/master/GMT%E6%AD%A3%E5%BC%8F%E6%A0%87%E5%87%86&#34;&gt;https://github.com/guanzhi/GM-Standards/tree/master/GMT%E6%AD%A3%E5%BC%8F%E6%A0%87%E5%87%86&lt;/a&gt;  （SM9官方的文档）&lt;/p&gt;
&lt;p&gt;[4] &lt;a href=&#34;https://secbit.feishu.cn/file/boxcns9RDCY0HIfW3gcXIWWDcBc&#34;&gt;https://secbit.feishu.cn/file/boxcns9RDCY0HIfW3gcXIWWDcBc&lt;/a&gt;  （飞书总结文档）&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
